/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> open(SS, immer::flex_vector<PtrVal>);
std::monostate open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> close(SS, immer::flex_vector<PtrVal>);
std::monostate close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> read(SS, immer::flex_vector<PtrVal>);
std::monostate read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> write(SS, immer::flex_vector<PtrVal>);
std::monostate write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> lseek(SS, immer::flex_vector<PtrVal>);
std::monostate lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> stat(SS, immer::flex_vector<PtrVal>);
std::monostate stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);

/************* Functions **************/
inline immer::flex_vector<std::pair<SS, PtrVal>> stat(SS x118, immer::flex_vector<PtrVal> x119) {
FS x120 = x118.get_fs();
PtrVal x121 = x119.at(0);
String x122 = get_string(x121, x118);
immer::map<String, File> x123 = x120.files;
bool x124 = Map::contains(x123, x122);
immer::flex_vector<std::pair<SS, PtrVal>> x125 = !x124 ? ({
x118.set_fs(x120);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x118, make_IntV(-1L, 32))};
}) : ({
PtrVal x126 = x119.at(1);
File x127 = x120.files.at(x122);
SS x128 = x118.update_seq(x126, x127.stat);
x128.set_fs(x120);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x128, make_IntV(0L, 32))};
});
return x125;
}
inline std::monostate stat(SS x129, immer::flex_vector<PtrVal> x130, std::function<std::monostate(SS, PtrVal)> x131) {
FS x132 = x129.get_fs();
PtrVal x133 = x130.at(0);
String x134 = get_string(x133, x129);
immer::map<String, File> x135 = x132.files;
bool x136 = Map::contains(x135, x134);
std::monostate x137 = !x136 ? ({
x129.set_fs(x132);
x131(x129, make_IntV(-1L, 32));
}) : ({
PtrVal x138 = x130.at(1);
File x139 = x132.files.at(x134);
SS x140 = x129.update_seq(x138, x139.stat);
x140.set_fs(x132);
x131(x140, make_IntV(0L, 32));
});
return x137;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> lseek(SS x103, immer::flex_vector<PtrVal> x104) {
FS x105 = x103.get_fs();
PtrVal x106 = x104.at(0);
PtrVal x107 = x104.at(1);
PtrVal x108 = x104.at(2);
int64_t x109 = x105.seek_file((int64_t)proj_IntV(x106), (int64_t)proj_IntV(x107), (int64_t)proj_IntV(x108));
x103.set_fs(x105);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x103, make_IntV(x109, 64))};
}
inline std::monostate lseek(SS x110, immer::flex_vector<PtrVal> x111, std::function<std::monostate(SS, PtrVal)> x112) {
FS x113 = x110.get_fs();
PtrVal x114 = x111.at(0);
PtrVal x115 = x111.at(1);
PtrVal x116 = x111.at(2);
int64_t x117 = x113.seek_file((int64_t)proj_IntV(x114), (int64_t)proj_IntV(x115), (int64_t)proj_IntV(x116));
x110.set_fs(x113);
return x112(x110, make_IntV(x117, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> write(SS x78, immer::flex_vector<PtrVal> x79) {
FS x80 = x78.get_fs();
PtrVal x81 = x79.at(0);
int64_t x82 = (int64_t)proj_IntV(x81);
bool x83 = x80.has_stream(x82);
immer::flex_vector<std::pair<SS, PtrVal>> x84 = !x83 ? ({
x78.set_fs(x80);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x78, make_IntV(-1L, 64))};
}) : ({
PtrVal x85 = x79.at(1);
PtrVal x86 = x79.at(2);
int64_t x87 = (int64_t)proj_IntV(x86);
Stream x88 = x80.get_stream(x82);
int x89 = x88.write(x78.at_seq(x85, x87), x87);
x80.set_stream(x82, x88);
x78.set_fs(x80);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x78, make_IntV((int64_t)x89, 64))};
});
return x84;
}
inline std::monostate write(SS x90, immer::flex_vector<PtrVal> x91, std::function<std::monostate(SS, PtrVal)> x92) {
FS x93 = x90.get_fs();
PtrVal x94 = x91.at(0);
int64_t x95 = (int64_t)proj_IntV(x94);
bool x96 = x93.has_stream(x95);
std::monostate x97 = !x96 ? ({
x90.set_fs(x93);
x92(x90, make_IntV(-1L, 64));
}) : ({
PtrVal x98 = x91.at(1);
PtrVal x99 = x91.at(2);
int64_t x100 = (int64_t)proj_IntV(x99);
Stream x101 = x93.get_stream(x95);
int x102 = x101.write(x90.at_seq(x98, x100), x100);
x93.set_stream(x95, x101);
x90.set_fs(x93);
x92(x90, make_IntV((int64_t)x102, 64));
});
return x97;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> read(SS x45, immer::flex_vector<PtrVal> x46) {
FS x47 = x45.get_fs();
PtrVal x48 = x46.at(0);
int64_t x49 = (int64_t)proj_IntV(x48);
bool x50 = x47.has_stream(x49);
immer::flex_vector<std::pair<SS, PtrVal>> x51 = !x50 ? ({
x45.set_fs(x47);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x45, make_IntV(-1L, 64))};
}) : ({
PtrVal x52 = x46.at(1);
PtrVal x53 = x46.at(2);
Stream x54 = x47.get_stream(x49);
int64_t x55 = x54.cursor;
immer::flex_vector<PtrVal> x56 = x54.file.content.drop((int)x55);
immer::flex_vector<PtrVal> x57 = x56.take((int)(int64_t)(int64_t)proj_IntV(x53));
int x58 = x57.size();
int64_t x59 = (int64_t)x58;
x54.cursor = x55 + x59;
x47.set_stream(x49, x54);
SS x60 = x45.update_seq(x52, x57);
x60.set_fs(x47);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x60, make_IntV(x59, 64))};
});
return x51;
}
inline std::monostate read(SS x61, immer::flex_vector<PtrVal> x62, std::function<std::monostate(SS, PtrVal)> x63) {
FS x64 = x61.get_fs();
PtrVal x65 = x62.at(0);
int64_t x66 = (int64_t)proj_IntV(x65);
bool x67 = x64.has_stream(x66);
std::monostate x68 = !x67 ? ({
x61.set_fs(x64);
x63(x61, make_IntV(-1L, 64));
}) : ({
PtrVal x69 = x62.at(1);
PtrVal x70 = x62.at(2);
Stream x71 = x64.get_stream(x66);
int64_t x72 = x71.cursor;
immer::flex_vector<PtrVal> x73 = x71.file.content.drop((int)x72);
immer::flex_vector<PtrVal> x74 = x73.take((int)(int64_t)(int64_t)proj_IntV(x70));
int x75 = x74.size();
int64_t x76 = (int64_t)x75;
x71.cursor = x72 + x76;
x64.set_stream(x66, x71);
SS x77 = x61.update_seq(x69, x74);
x77.set_fs(x64);
x63(x77, make_IntV(x76, 64));
});
return x68;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> close(SS x22, immer::flex_vector<PtrVal> x23) {
FS x24 = x22.get_fs();
PtrVal x25 = x23.at(0);
int64_t x26 = (int64_t)proj_IntV(x25->to_IntV());
bool x27 = x24.has_stream(x26);
immer::flex_vector<std::pair<SS, PtrVal>> x28 = !x27 ? ({
x22.set_fs(x24);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x22, make_IntV(-1L, 32))};
}) : ({
File x29 = x24.get_stream(x26).file;
String x30 = x29.name;
immer::map<String, File> x31 = x24.files;
bool x32 = Map::contains(x31, x30);
if (x32) {
x24.set_file(x30, x29);
x24.remove_stream(x26);
}
x22.set_fs(x24);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x22, make_IntV(0L, 32))};
});
return x28;
}
inline std::monostate close(SS x33, immer::flex_vector<PtrVal> x34, std::function<std::monostate(SS, PtrVal)> x35) {
FS x36 = x33.get_fs();
PtrVal x37 = x34.at(0);
int64_t x38 = (int64_t)proj_IntV(x37->to_IntV());
bool x39 = x36.has_stream(x38);
std::monostate x40 = !x39 ? ({
x33.set_fs(x36);
x35(x33, make_IntV(-1L, 32));
}) : ({
File x41 = x36.get_stream(x38).file;
String x42 = x41.name;
immer::map<String, File> x43 = x36.files;
bool x44 = Map::contains(x43, x42);
if (x44) {
x36.set_file(x42, x41);
x36.remove_stream(x38);
}
x33.set_fs(x36);
x35(x33, make_IntV(0L, 32));
});
return x40;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
String x5 = get_string(x4, x1);
immer::map<String, File> x6 = x3.files;
bool x7 = Map::contains(x6, x5);
immer::flex_vector<std::pair<SS, PtrVal>> x8 = !x7 ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x9 = x3.get_fresh_fd();
File x10 = x3.files.at(x5);
x3.set_stream(x9, Stream(x10));
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x9, 32))};
});
return x8;
}
inline std::monostate open(SS x11, immer::flex_vector<PtrVal> x12, std::function<std::monostate(SS, PtrVal)> x13) {
FS x14 = x11.get_fs();
PtrVal x15 = x12.at(0);
String x16 = get_string(x15, x11);
immer::map<String, File> x17 = x14.files;
bool x18 = Map::contains(x17, x16);
std::monostate x19 = !x18 ? ({
x11.set_fs(x14);
x13(x11, make_IntV(-1L, 32));
}) : ({
int x20 = x14.get_fresh_fd();
File x21 = x14.files.at(x16);
x14.set_stream(x20, Stream(x21));
x11.set_fs(x14);
x13(x11, make_IntV((int64_t)x20, 32));
});
return x19;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
