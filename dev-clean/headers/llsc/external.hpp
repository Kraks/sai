/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);

/************* Functions **************/
inline FS set_file(FS x179, String x180, Ptr<File> x181) {
x179.root_file;
return x179;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x156, immer::flex_vector<PtrVal> x157) {
FS x158 = x156.get_fs();
PtrVal x159 = x157.at(0);
String x160 = get_string(x159, x156);
Ptr<File> x161 = x158.root_file;
bool x162 = Map::contains(x161->children, x160);
immer::flex_vector<std::pair<SS, PtrVal>> x163 = !x162 ? ({
x156.set_fs(x158);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x156, make_IntV(-1L, 32))};
}) : ({
PtrVal x164 = x157.at(1);
Ptr<File> x165 = x158.root_file->children.at(x160);
SS x166 = x156.update_seq(x164, x165->stat);
x166.set_fs(x158);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x166, make_IntV(0L, 32))};
});
return x163;
}
inline std::monostate syscall_stat(SS x167, immer::flex_vector<PtrVal> x168, std::function<std::monostate(SS, PtrVal)> x169) {
FS x170 = x167.get_fs();
PtrVal x171 = x168.at(0);
String x172 = get_string(x171, x167);
Ptr<File> x173 = x170.root_file;
bool x174 = Map::contains(x173->children, x172);
std::monostate x175 = !x174 ? ({
x167.set_fs(x170);
x169(x167, make_IntV(-1L, 32));
}) : ({
PtrVal x176 = x168.at(1);
Ptr<File> x177 = x170.root_file->children.at(x172);
SS x178 = x167.update_seq(x176, x177->stat);
x178.set_fs(x170);
x169(x178, make_IntV(0L, 32));
});
return x175;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x141, immer::flex_vector<PtrVal> x142) {
FS x143 = x141.get_fs();
PtrVal x144 = x142.at(0);
PtrVal x145 = x142.at(1);
PtrVal x146 = x142.at(2);
int64_t x147 = x143.seek_file(proj_IntV(x144), proj_IntV(x145), (int)proj_IntV(x146));
x141.set_fs(x143);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x141, make_IntV(x147, 64))};
}
inline std::monostate syscall_lseek(SS x148, immer::flex_vector<PtrVal> x149, std::function<std::monostate(SS, PtrVal)> x150) {
FS x151 = x148.get_fs();
PtrVal x152 = x149.at(0);
PtrVal x153 = x149.at(1);
PtrVal x154 = x149.at(2);
int64_t x155 = x151.seek_file(proj_IntV(x152), proj_IntV(x153), (int)proj_IntV(x154));
x148.set_fs(x151);
return x150(x148, make_IntV(x155, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x86, immer::flex_vector<PtrVal> x87) {
FS x88 = x86.get_fs();
PtrVal x89 = x87.at(0);
int x90 = (int)proj_IntV(x89);
immer::map<int, Stream> x91 = x88.opened_files;
bool x92 = Map::contains(x91, x90);
immer::flex_vector<std::pair<SS, PtrVal>> x93 = !x92 ? ({
x86.set_fs(x88);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x86, make_IntV(-1L, 64))};
}) : ({
PtrVal x94 = x87.at(1);
PtrVal x95 = x87.at(2);
int x96 = (int)proj_IntV(x95);
Stream x97 = x88.opened_files.at(x90);
immer::flex_vector<PtrVal> x98 = x86.at_seq(x94, x96).take((int)(int64_t)x96);
Ptr<File> x99 = x97.file;
int64_t x100 = x97.cursor;
// File.writeAt;
int x101 = (int)x100;
int x102 = x99->content.size();
int x103 = x101 - x102;
if (x103 > 0) {
immer::flex_vector<PtrVal> x104 = immer::flex_vector<PtrVal>(x103, IntV0);
immer::flex_vector<PtrVal> x105 = x99->content + x104;
x99->content = x105;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x106 = x99->content.take(x101);
immer::flex_vector<PtrVal> x107 = x106 + x98;
int x108 = x98.size();
immer::flex_vector<PtrVal> x109 = x99->content.drop(x101 + x108);
immer::flex_vector<PtrVal> x110 = x107 + x109;
x99->content = x110;
x97.file = x99;
int64_t x111 = (int64_t)x108;
x97.cursor = x100 + x111;
immer::map<int, Stream> x112 = x88.opened_files.insert(std::make_pair(x90, x97));
x88.opened_files = x112;
x86.set_fs(x88);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x86, make_IntV(x111, 64))};
});
return x93;
}
inline std::monostate syscall_write(SS x113, immer::flex_vector<PtrVal> x114, std::function<std::monostate(SS, PtrVal)> x115) {
FS x116 = x113.get_fs();
PtrVal x117 = x114.at(0);
int x118 = (int)proj_IntV(x117);
immer::map<int, Stream> x119 = x116.opened_files;
bool x120 = Map::contains(x119, x118);
std::monostate x121 = !x120 ? ({
x113.set_fs(x116);
x115(x113, make_IntV(-1L, 64));
}) : ({
PtrVal x122 = x114.at(1);
PtrVal x123 = x114.at(2);
int x124 = (int)proj_IntV(x123);
Stream x125 = x116.opened_files.at(x118);
immer::flex_vector<PtrVal> x126 = x113.at_seq(x122, x124).take((int)(int64_t)x124);
Ptr<File> x127 = x125.file;
int64_t x128 = x125.cursor;
// File.writeAt;
int x129 = (int)x128;
int x130 = x127->content.size();
int x131 = x129 - x130;
if (x131 > 0) {
immer::flex_vector<PtrVal> x132 = immer::flex_vector<PtrVal>(x131, IntV0);
immer::flex_vector<PtrVal> x133 = x127->content + x132;
x127->content = x133;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x134 = x127->content.take(x129);
immer::flex_vector<PtrVal> x135 = x134 + x126;
int x136 = x126.size();
immer::flex_vector<PtrVal> x137 = x127->content.drop(x129 + x136);
immer::flex_vector<PtrVal> x138 = x135 + x137;
x127->content = x138;
x125.file = x127;
int64_t x139 = (int64_t)x136;
x125.cursor = x128 + x139;
immer::map<int, Stream> x140 = x116.opened_files.insert(std::make_pair(x118, x125));
x116.opened_files = x140;
x113.set_fs(x116);
x115(x113, make_IntV(x139, 64));
});
return x121;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x49, immer::flex_vector<PtrVal> x50) {
FS x51 = x49.get_fs();
PtrVal x52 = x50.at(0);
int x53 = (int)proj_IntV(x52);
immer::map<int, Stream> x54 = x51.opened_files;
bool x55 = Map::contains(x54, x53);
immer::flex_vector<std::pair<SS, PtrVal>> x56 = !x55 ? ({
x49.set_fs(x51);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x49, make_IntV(-1L, 64))};
}) : ({
PtrVal x57 = x50.at(1);
PtrVal x58 = x50.at(2);
Stream x59 = x51.opened_files.at(x53);
int64_t x60 = x59.cursor;
immer::flex_vector<PtrVal> x61 = x59.file->content.drop((int)x60);
immer::flex_vector<PtrVal> x62 = x61.take((int)(int64_t)(int)proj_IntV(x58));
int x63 = x62.size();
int64_t x64 = (int64_t)x63;
x59.cursor = x60 + x64;
immer::map<int, Stream> x65 = x51.opened_files.insert(std::make_pair(x53, x59));
x51.opened_files = x65;
SS x66 = x49.update_seq(x57, x62);
x66.set_fs(x51);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x66, make_IntV(x64, 64))};
});
return x56;
}
inline std::monostate syscall_read(SS x67, immer::flex_vector<PtrVal> x68, std::function<std::monostate(SS, PtrVal)> x69) {
FS x70 = x67.get_fs();
PtrVal x71 = x68.at(0);
int x72 = (int)proj_IntV(x71);
immer::map<int, Stream> x73 = x70.opened_files;
bool x74 = Map::contains(x73, x72);
std::monostate x75 = !x74 ? ({
x67.set_fs(x70);
x69(x67, make_IntV(-1L, 64));
}) : ({
PtrVal x76 = x68.at(1);
PtrVal x77 = x68.at(2);
Stream x78 = x70.opened_files.at(x72);
int64_t x79 = x78.cursor;
immer::flex_vector<PtrVal> x80 = x78.file->content.drop((int)x79);
immer::flex_vector<PtrVal> x81 = x80.take((int)(int64_t)(int)proj_IntV(x77));
int x82 = x81.size();
int64_t x83 = (int64_t)x82;
x78.cursor = x79 + x83;
immer::map<int, Stream> x84 = x70.opened_files.insert(std::make_pair(x72, x78));
x70.opened_files = x84;
SS x85 = x67.update_seq(x76, x81);
x85.set_fs(x70);
x69(x85, make_IntV(x83, 64));
});
return x75;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x24, immer::flex_vector<PtrVal> x25) {
FS x26 = x24.get_fs();
PtrVal x27 = x25.at(0);
int x28 = (int)proj_IntV(x27);
immer::map<int, Stream> x29 = x26.opened_files;
bool x30 = Map::contains(x29, x28);
immer::flex_vector<std::pair<SS, PtrVal>> x31 = !x30 ? ({
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(-1L, 32))};
}) : ({
Stream x32 = x26.opened_files.at(x28);
Ptr<File> x33 = x26.root_file;
bool x34 = Map::contains(x33->children, x32.file->name);
if (x34) {
x26.root_file;
immer::map<int, Stream> x35 = x26.opened_files.erase(x28);
x26.opened_files = x35;
}
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(0L, 32))};
});
return x31;
}
inline std::monostate syscall_close(SS x36, immer::flex_vector<PtrVal> x37, std::function<std::monostate(SS, PtrVal)> x38) {
FS x39 = x36.get_fs();
PtrVal x40 = x37.at(0);
int x41 = (int)proj_IntV(x40);
immer::map<int, Stream> x42 = x39.opened_files;
bool x43 = Map::contains(x42, x41);
std::monostate x44 = !x43 ? ({
x36.set_fs(x39);
x38(x36, make_IntV(-1L, 32));
}) : ({
Stream x45 = x39.opened_files.at(x41);
Ptr<File> x46 = x39.root_file;
bool x47 = Map::contains(x46->children, x45.file->name);
if (x47) {
x39.root_file;
immer::map<int, Stream> x48 = x39.opened_files.erase(x41);
x39.opened_files = x48;
}
x36.set_fs(x39);
x38(x36, make_IntV(0L, 32));
});
return x44;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
String x5 = get_string(x4, x1);
Ptr<File> x6 = x3.root_file;
bool x7 = Map::contains(x6->children, x5);
immer::flex_vector<std::pair<SS, PtrVal>> x8 = !x7 ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x9 = x3.get_fresh_fd();
Ptr<File> x10 = x3.root_file->children.at(x5);
immer::map<int, Stream> x11 = x3.opened_files.insert(std::make_pair(x9, Stream(x10)));
x3.opened_files = x11;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x9, 32))};
});
return x8;
}
inline std::monostate syscall_open(SS x12, immer::flex_vector<PtrVal> x13, std::function<std::monostate(SS, PtrVal)> x14) {
FS x15 = x12.get_fs();
PtrVal x16 = x13.at(0);
String x17 = get_string(x16, x12);
Ptr<File> x18 = x15.root_file;
bool x19 = Map::contains(x18->children, x17);
std::monostate x20 = !x19 ? ({
x12.set_fs(x15);
x14(x12, make_IntV(-1L, 32));
}) : ({
int x21 = x15.get_fresh_fd();
Ptr<File> x22 = x15.root_file->children.at(x17);
immer::map<int, Stream> x23 = x15.opened_files.insert(std::make_pair(x21, Stream(x22)));
x15.opened_files = x23;
x12.set_fs(x15);
x14(x12, make_IntV((int64_t)x21, 32));
});
return x20;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
