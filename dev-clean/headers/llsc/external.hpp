/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);

/************* Functions **************/
inline FS set_file(FS x223, String x224, Ptr<File> x225) {
Ptr<File> x226 = x223.root_file;
immer::map<String, Ptr<File>> x227 = x226->children.insert(std::make_pair(x224, x225));
x226->children = x227;
return x223;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x200, immer::flex_vector<PtrVal> x201) {
FS x202 = x200.get_fs();
PtrVal x203 = x201.at(0);
String x204 = get_string(x203, x200);
Ptr<File> x205 = x202.root_file;
bool x206 = Map::contains(x205->children, x204);
immer::flex_vector<std::pair<SS, PtrVal>> x207 = !x206 ? ({
x200.set_fs(x202);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x200, make_IntV(-1L, 32))};
}) : ({
PtrVal x208 = x201.at(1);
Ptr<File> x209 = x202.root_file->children.at(x204);
SS x210 = x200.update_seq(x208, x209->stat);
x210.set_fs(x202);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x210, make_IntV(0L, 32))};
});
return x207;
}
inline std::monostate syscall_stat(SS x211, immer::flex_vector<PtrVal> x212, std::function<std::monostate(SS, PtrVal)> x213) {
FS x214 = x211.get_fs();
PtrVal x215 = x212.at(0);
String x216 = get_string(x215, x211);
Ptr<File> x217 = x214.root_file;
bool x218 = Map::contains(x217->children, x216);
std::monostate x219 = !x218 ? ({
x211.set_fs(x214);
x213(x211, make_IntV(-1L, 32));
}) : ({
PtrVal x220 = x212.at(1);
Ptr<File> x221 = x214.root_file->children.at(x216);
SS x222 = x211.update_seq(x220, x221->stat);
x222.set_fs(x214);
x213(x222, make_IntV(0L, 32));
});
return x219;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x147, immer::flex_vector<PtrVal> x148) {
FS x149 = x147.get_fs();
PtrVal x150 = x148.at(0);
int x151 = (int)proj_IntV(x150);
immer::map<int, Stream> x152 = x149.opened_files;
bool x153 = Map::contains(x152, x151);
int64_t x154 = !x153 ? -1L : ({
PtrVal x155 = x148.at(2);
int x156 = (int)proj_IntV(x155);
immer::map<int, Stream> x157 = x149.opened_files;
Stream x158 = x157.at(x151);
int64_t x159 = x156 == SEEK_SET ? ({
PtrVal x160 = x148.at(1);
int64_t x161 = proj_IntV(x160);
int64_t x162 = x161 < 0L ? -1L : ({
x158.cursor = x161;
x161;
});
x162;
}) : ({
int64_t x163 = x156 == SEEK_CUR ? ({
PtrVal x160 = x148.at(1);
int64_t x164 = x158.cursor;
int64_t x165 = x164 + proj_IntV(x160);
int64_t x166 = x165 < 0L ? -1L : ({
x158.cursor = x165;
x165;
});
x166;
}) : ({
int64_t x167 = x156 == SEEK_END ? ({
PtrVal x160 = x148.at(1);
Ptr<File> x168 = x158.file;
int x169 = x168->content.size();
int64_t x170 = (int64_t)x169 + proj_IntV(x160);
int64_t x171 = x170 < 0L ? -1L : ({
x158.cursor = x170;
x170;
});
x171;
}) : -1L;
x167;
});
x163;
});
immer::map<int, Stream> x172 = x149.opened_files.insert(std::make_pair(x151, x158));
x149.opened_files = x172;
x159;
});
x147.set_fs(x149);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x147, make_IntV(x154, 64))};
}
inline std::monostate syscall_lseek(SS x173, immer::flex_vector<PtrVal> x174, std::function<std::monostate(SS, PtrVal)> x175) {
FS x176 = x173.get_fs();
PtrVal x177 = x174.at(0);
int x178 = (int)proj_IntV(x177);
immer::map<int, Stream> x179 = x176.opened_files;
bool x180 = Map::contains(x179, x178);
int64_t x181 = !x180 ? -1L : ({
PtrVal x182 = x174.at(2);
int x183 = (int)proj_IntV(x182);
immer::map<int, Stream> x184 = x176.opened_files;
Stream x185 = x184.at(x178);
int64_t x186 = x183 == SEEK_SET ? ({
PtrVal x187 = x174.at(1);
int64_t x188 = proj_IntV(x187);
int64_t x189 = x188 < 0L ? -1L : ({
x185.cursor = x188;
x188;
});
x189;
}) : ({
int64_t x190 = x183 == SEEK_CUR ? ({
PtrVal x187 = x174.at(1);
int64_t x191 = x185.cursor;
int64_t x192 = x191 + proj_IntV(x187);
int64_t x193 = x192 < 0L ? -1L : ({
x185.cursor = x192;
x192;
});
x193;
}) : ({
int64_t x194 = x183 == SEEK_END ? ({
PtrVal x187 = x174.at(1);
Ptr<File> x195 = x185.file;
int x196 = x195->content.size();
int64_t x197 = (int64_t)x196 + proj_IntV(x187);
int64_t x198 = x197 < 0L ? -1L : ({
x185.cursor = x197;
x197;
});
x198;
}) : -1L;
x194;
});
x190;
});
immer::map<int, Stream> x199 = x176.opened_files.insert(std::make_pair(x178, x185));
x176.opened_files = x199;
x186;
});
x173.set_fs(x176);
return x175(x173, make_IntV(x181, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x92, immer::flex_vector<PtrVal> x93) {
FS x94 = x92.get_fs();
PtrVal x95 = x93.at(0);
int x96 = (int)proj_IntV(x95);
immer::map<int, Stream> x97 = x94.opened_files;
bool x98 = Map::contains(x97, x96);
immer::flex_vector<std::pair<SS, PtrVal>> x99 = !x98 ? ({
x92.set_fs(x94);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x92, make_IntV(-1L, 64))};
}) : ({
PtrVal x100 = x93.at(1);
PtrVal x101 = x93.at(2);
int x102 = (int)proj_IntV(x101);
Stream x103 = x94.opened_files.at(x96);
immer::flex_vector<PtrVal> x104 = x92.at_seq(x100, x102).take((int)(int64_t)x102);
Ptr<File> x105 = x103.file;
int64_t x106 = x103.cursor;
// File.writeAt;
int x107 = (int)x106;
int x108 = x105->content.size();
int x109 = x107 - x108;
if (x109 > 0) {
immer::flex_vector<PtrVal> x110 = immer::flex_vector<PtrVal>(x109, IntV0);
immer::flex_vector<PtrVal> x111 = x105->content + x110;
x105->content = x111;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x112 = x105->content.take(x107);
immer::flex_vector<PtrVal> x113 = x112 + x104;
int x114 = x104.size();
immer::flex_vector<PtrVal> x115 = x105->content.drop(x107 + x114);
immer::flex_vector<PtrVal> x116 = x113 + x115;
x105->content = x116;
int64_t x117 = (int64_t)x114;
x103.cursor = x103.cursor + x117;
immer::map<int, Stream> x118 = x94.opened_files.insert(std::make_pair(x96, x103));
x94.opened_files = x118;
x92.set_fs(x94);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x92, make_IntV(x117, 64))};
});
return x99;
}
inline std::monostate syscall_write(SS x119, immer::flex_vector<PtrVal> x120, std::function<std::monostate(SS, PtrVal)> x121) {
FS x122 = x119.get_fs();
PtrVal x123 = x120.at(0);
int x124 = (int)proj_IntV(x123);
immer::map<int, Stream> x125 = x122.opened_files;
bool x126 = Map::contains(x125, x124);
std::monostate x127 = !x126 ? ({
x119.set_fs(x122);
x121(x119, make_IntV(-1L, 64));
}) : ({
PtrVal x128 = x120.at(1);
PtrVal x129 = x120.at(2);
int x130 = (int)proj_IntV(x129);
Stream x131 = x122.opened_files.at(x124);
immer::flex_vector<PtrVal> x132 = x119.at_seq(x128, x130).take((int)(int64_t)x130);
Ptr<File> x133 = x131.file;
int64_t x134 = x131.cursor;
// File.writeAt;
int x135 = (int)x134;
int x136 = x133->content.size();
int x137 = x135 - x136;
if (x137 > 0) {
immer::flex_vector<PtrVal> x138 = immer::flex_vector<PtrVal>(x137, IntV0);
immer::flex_vector<PtrVal> x139 = x133->content + x138;
x133->content = x139;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x140 = x133->content.take(x135);
immer::flex_vector<PtrVal> x141 = x140 + x132;
int x142 = x132.size();
immer::flex_vector<PtrVal> x143 = x133->content.drop(x135 + x142);
immer::flex_vector<PtrVal> x144 = x141 + x143;
x133->content = x144;
int64_t x145 = (int64_t)x142;
x131.cursor = x131.cursor + x145;
immer::map<int, Stream> x146 = x122.opened_files.insert(std::make_pair(x124, x131));
x122.opened_files = x146;
x119.set_fs(x122);
x121(x119, make_IntV(x145, 64));
});
return x127;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x57, immer::flex_vector<PtrVal> x58) {
FS x59 = x57.get_fs();
PtrVal x60 = x58.at(0);
int x61 = (int)proj_IntV(x60);
immer::map<int, Stream> x62 = x59.opened_files;
bool x63 = Map::contains(x62, x61);
immer::flex_vector<std::pair<SS, PtrVal>> x64 = !x63 ? ({
x57.set_fs(x59);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x57, make_IntV(-1L, 64))};
}) : ({
PtrVal x65 = x58.at(1);
PtrVal x66 = x58.at(2);
Stream x67 = x59.opened_files.at(x61);
immer::flex_vector<PtrVal> x68 = x67.file->content.drop((int)x67.cursor);
immer::flex_vector<PtrVal> x69 = x68.take((int)(int64_t)(int)proj_IntV(x66));
int x70 = x69.size();
int64_t x71 = (int64_t)x70;
x67.cursor = x67.cursor + x71;
immer::map<int, Stream> x72 = x59.opened_files.insert(std::make_pair(x61, x67));
x59.opened_files = x72;
SS x73 = x57.update_seq(x65, x69);
x73.set_fs(x59);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x73, make_IntV(x71, 64))};
});
return x64;
}
inline std::monostate syscall_read(SS x74, immer::flex_vector<PtrVal> x75, std::function<std::monostate(SS, PtrVal)> x76) {
FS x77 = x74.get_fs();
PtrVal x78 = x75.at(0);
int x79 = (int)proj_IntV(x78);
immer::map<int, Stream> x80 = x77.opened_files;
bool x81 = Map::contains(x80, x79);
std::monostate x82 = !x81 ? ({
x74.set_fs(x77);
x76(x74, make_IntV(-1L, 64));
}) : ({
PtrVal x83 = x75.at(1);
PtrVal x84 = x75.at(2);
Stream x85 = x77.opened_files.at(x79);
immer::flex_vector<PtrVal> x86 = x85.file->content.drop((int)x85.cursor);
immer::flex_vector<PtrVal> x87 = x86.take((int)(int64_t)(int)proj_IntV(x84));
int x88 = x87.size();
int64_t x89 = (int64_t)x88;
x85.cursor = x85.cursor + x89;
immer::map<int, Stream> x90 = x77.opened_files.insert(std::make_pair(x79, x85));
x77.opened_files = x90;
SS x91 = x74.update_seq(x83, x87);
x91.set_fs(x77);
x76(x91, make_IntV(x89, 64));
});
return x82;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x24, immer::flex_vector<PtrVal> x25) {
FS x26 = x24.get_fs();
PtrVal x27 = x25.at(0);
int x28 = (int)proj_IntV(x27);
immer::map<int, Stream> x29 = x26.opened_files;
bool x30 = Map::contains(x29, x28);
immer::flex_vector<std::pair<SS, PtrVal>> x31 = !x30 ? ({
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(-1L, 32))};
}) : ({
Stream x32 = x26.opened_files.at(x28);
String x33 = x32.file->name;
Ptr<File> x34 = x26.root_file;
bool x35 = Map::contains(x34->children, x33);
if (x35) {
Ptr<File> x36 = x32.file;
Ptr<File> x37 = x26.root_file;
immer::map<String, Ptr<File>> x38 = x37->children.insert(std::make_pair(x33, x36));
x37->children = x38;
immer::map<int, Stream> x39 = x26.opened_files.erase(x28);
x26.opened_files = x39;
}
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(0L, 32))};
});
return x31;
}
inline std::monostate syscall_close(SS x40, immer::flex_vector<PtrVal> x41, std::function<std::monostate(SS, PtrVal)> x42) {
FS x43 = x40.get_fs();
PtrVal x44 = x41.at(0);
int x45 = (int)proj_IntV(x44);
immer::map<int, Stream> x46 = x43.opened_files;
bool x47 = Map::contains(x46, x45);
std::monostate x48 = !x47 ? ({
x40.set_fs(x43);
x42(x40, make_IntV(-1L, 32));
}) : ({
Stream x49 = x43.opened_files.at(x45);
String x50 = x49.file->name;
Ptr<File> x51 = x43.root_file;
bool x52 = Map::contains(x51->children, x50);
if (x52) {
Ptr<File> x53 = x49.file;
Ptr<File> x54 = x43.root_file;
immer::map<String, Ptr<File>> x55 = x54->children.insert(std::make_pair(x50, x53));
x54->children = x55;
immer::map<int, Stream> x56 = x43.opened_files.erase(x45);
x43.opened_files = x56;
}
x40.set_fs(x43);
x42(x40, make_IntV(0L, 32));
});
return x48;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
String x5 = get_string(x4, x1);
Ptr<File> x6 = x3.root_file;
bool x7 = Map::contains(x6->children, x5);
immer::flex_vector<std::pair<SS, PtrVal>> x8 = !x7 ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x9 = x3.get_fresh_fd();
Ptr<File> x10 = x3.root_file->children.at(x5);
immer::map<int, Stream> x11 = x3.opened_files.insert(std::make_pair(x9, Stream(x10)));
x3.opened_files = x11;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x9, 32))};
});
return x8;
}
inline std::monostate syscall_open(SS x12, immer::flex_vector<PtrVal> x13, std::function<std::monostate(SS, PtrVal)> x14) {
FS x15 = x12.get_fs();
PtrVal x16 = x13.at(0);
String x17 = get_string(x16, x12);
Ptr<File> x18 = x15.root_file;
bool x19 = Map::contains(x18->children, x17);
std::monostate x20 = !x19 ? ({
x12.set_fs(x15);
x14(x12, make_IntV(-1L, 32));
}) : ({
int x21 = x15.get_fresh_fd();
Ptr<File> x22 = x15.root_file->children.at(x17);
immer::map<int, Stream> x23 = x15.opened_files.insert(std::make_pair(x21, Stream(x22)));
x15.opened_files = x23;
x12.set_fs(x15);
x14(x12, make_IntV((int64_t)x21, 32));
});
return x20;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
