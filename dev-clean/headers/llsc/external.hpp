/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);
Ptr<File> set_file_type(Ptr<File>, int);
bool has_file_type(Ptr<File>, int);

/************* Functions **************/
inline bool has_file_type(Ptr<File> x356, int x357) {
immer::flex_vector<PtrVal> x358 = x356->stat.drop(24);
immer::flex_vector<PtrVal> x359 = x358.take(4);
return (bool)(proj_IntV(Value::from_bytes(x359)) & (int64_t)x357);
}
inline Ptr<File> set_file_type(Ptr<File> x346, int x347) {
immer::flex_vector<PtrVal> x348 = x346->stat.drop(24);
immer::flex_vector<PtrVal> x349 = x348.take(4);
immer::flex_vector<PtrVal> x350 = make_IntV(proj_IntV(Value::from_bytes(x349)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)x347, 32)->to_bytes();
immer::flex_vector<PtrVal> x351 = x346->stat.take(24);
immer::flex_vector<PtrVal> x352 = x351 + x350;
int x353 = x350.size();
immer::flex_vector<PtrVal> x354 = x346->stat.drop(24 + x353);
immer::flex_vector<PtrVal> x355 = x352 + x354;
x346->stat = x355;
return x346;
}
inline FS set_file(FS x329, String x330, Ptr<File> x331) {
/* setFile */;
immer::flex_vector<String> x332 = Vec::filter(Str::split(x330, "/"), [&](auto x333) {
return x333.length() > 0;
});
int x334 = x332.size();
immer::flex_vector<String> x335 = x332.take(x334 - 1);
Ptr<File> x336 = Vec::foldLeft(x335, x329.root_file, [&](auto x337, auto x338) {
bool x339 = x337 == nullptr || ({
bool x340 = Map::contains(x337->children, x338);
!x340;
});
Ptr<File> x341 = x339 ? nullptr : ({
Ptr<File> x342 = x337->children.at(x338);
x342;
});
return x341;
});
String x343 = x332.back();
String x344 = x331->name;
/* assertEq */;
ASSERT((x343 == x344), "setFile name should equal to last segment");
if (x336 != nullptr) {
immer::map<String, Ptr<File>> x345 = x336->children.insert(std::make_pair(x344, x331));
x336->children = x345;
}
return x329;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x274, immer::flex_vector<PtrVal> x275) {
FS x276 = x274.get_fs();
PtrVal x277 = x275.at(0);
/* getFile */;
Ptr<File> x278 = x276.root_file;
immer::flex_vector<String> x279 = Str::split(get_string(x277, x274), "/");
immer::flex_vector<String> x280 = Vec::filter(x279, [&](auto x281) {
return x281.length() > 0;
});
Ptr<File> x282 = Vec::foldLeft(x280, x278, [&](auto x283, auto x284) {
bool x285 = x283 == nullptr || ({
bool x286 = Map::contains(x283->children, x284);
!x286;
});
Ptr<File> x287 = x285 ? nullptr : ({
Ptr<File> x288 = x283->children.at(x284);
x288;
});
return x287;
});
immer::flex_vector<std::pair<SS, PtrVal>> x289 = !(x282 != nullptr) ? ({
x274.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x274, make_IntV(-1L, 32))};
}) : ({
PtrVal x290 = x275.at(1);
/* getFile */;
immer::flex_vector<String> x291 = Vec::filter(x279, [&](auto x292) {
return x292.length() > 0;
});
Ptr<File> x293 = Vec::foldLeft(x291, x276.root_file, [&](auto x294, auto x295) {
bool x296 = x294 == nullptr || ({
bool x297 = Map::contains(x294->children, x295);
!x297;
});
Ptr<File> x298 = x296 ? nullptr : ({
Ptr<File> x299 = x294->children.at(x295);
x299;
});
return x298;
});
SS x300 = x274.update_seq(x290, x293->stat);
x300.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x300, make_IntV(0L, 32))};
});
return x289;
}
inline std::monostate syscall_stat(SS x301, immer::flex_vector<PtrVal> x302, std::function<std::monostate(SS, PtrVal)> x303) {
FS x304 = x301.get_fs();
PtrVal x305 = x302.at(0);
/* getFile */;
Ptr<File> x306 = x304.root_file;
immer::flex_vector<String> x307 = Str::split(get_string(x305, x301), "/");
immer::flex_vector<String> x308 = Vec::filter(x307, [&](auto x309) {
return x309.length() > 0;
});
Ptr<File> x310 = Vec::foldLeft(x308, x306, [&](auto x311, auto x312) {
bool x313 = x311 == nullptr || ({
bool x314 = Map::contains(x311->children, x312);
!x314;
});
Ptr<File> x315 = x313 ? nullptr : ({
Ptr<File> x316 = x311->children.at(x312);
x316;
});
return x315;
});
std::monostate x317 = !(x310 != nullptr) ? ({
x301.set_fs(x304);
x303(x301, make_IntV(-1L, 32));
}) : ({
PtrVal x318 = x302.at(1);
/* getFile */;
immer::flex_vector<String> x319 = Vec::filter(x307, [&](auto x320) {
return x320.length() > 0;
});
Ptr<File> x321 = Vec::foldLeft(x319, x304.root_file, [&](auto x322, auto x323) {
bool x324 = x322 == nullptr || ({
bool x325 = Map::contains(x322->children, x323);
!x325;
});
Ptr<File> x326 = x324 ? nullptr : ({
Ptr<File> x327 = x322->children.at(x323);
x327;
});
return x326;
});
SS x328 = x301.update_seq(x318, x321->stat);
x328.set_fs(x304);
x303(x328, make_IntV(0L, 32));
});
return x317;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x223, immer::flex_vector<PtrVal> x224) {
FS x225 = x223.get_fs();
PtrVal x226 = x224.at(0);
int x227 = (int)proj_IntV(x226);
immer::map<int, Ptr<Stream>> x228 = x225.opened_files;
bool x229 = Map::contains(x228, x227);
int64_t x230 = !x229 ? -1L : ({
PtrVal x231 = x224.at(2);
int x232 = (int)proj_IntV(x231);
immer::map<int, Ptr<Stream>> x233 = x225.opened_files;
int64_t x234 = x232 == SEEK_SET ? ({
PtrVal x235 = x224.at(1);
int64_t x236 = proj_IntV(x235);
int64_t x237 = x236 < 0L ? -1L : ({
Ptr<Stream> x238 = x233.at(x227);
x238->cursor = x236;
x236;
});
x237;
}) : ({
int64_t x239 = x232 == SEEK_CUR ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
int64_t x240 = x238->cursor;
int64_t x241 = x240 + proj_IntV(x235);
int64_t x242 = x241 < 0L ? -1L : ({
x238->cursor = x241;
x241;
});
x242;
}) : ({
int64_t x243 = x232 == SEEK_END ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
Ptr<File> x244 = x238->file;
int x245 = x244->content.size();
int64_t x246 = (int64_t)x245 + proj_IntV(x235);
int64_t x247 = x246 < 0L ? -1L : ({
x238->cursor = x246;
x246;
});
x247;
}) : -1L;
x243;
});
x239;
});
x234;
});
x223.set_fs(x225);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x223, make_IntV(x230, 64))};
}
inline std::monostate syscall_lseek(SS x248, immer::flex_vector<PtrVal> x249, std::function<std::monostate(SS, PtrVal)> x250) {
FS x251 = x248.get_fs();
PtrVal x252 = x249.at(0);
int x253 = (int)proj_IntV(x252);
immer::map<int, Ptr<Stream>> x254 = x251.opened_files;
bool x255 = Map::contains(x254, x253);
int64_t x256 = !x255 ? -1L : ({
PtrVal x257 = x249.at(2);
int x258 = (int)proj_IntV(x257);
immer::map<int, Ptr<Stream>> x259 = x251.opened_files;
int64_t x260 = x258 == SEEK_SET ? ({
PtrVal x261 = x249.at(1);
int64_t x262 = proj_IntV(x261);
int64_t x263 = x262 < 0L ? -1L : ({
Ptr<Stream> x264 = x259.at(x253);
x264->cursor = x262;
x262;
});
x263;
}) : ({
int64_t x265 = x258 == SEEK_CUR ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
int64_t x266 = x264->cursor;
int64_t x267 = x266 + proj_IntV(x261);
int64_t x268 = x267 < 0L ? -1L : ({
x264->cursor = x267;
x267;
});
x268;
}) : ({
int64_t x269 = x258 == SEEK_END ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
Ptr<File> x270 = x264->file;
int x271 = x270->content.size();
int64_t x272 = (int64_t)x271 + proj_IntV(x261);
int64_t x273 = x272 < 0L ? -1L : ({
x264->cursor = x272;
x272;
});
x273;
}) : -1L;
x269;
});
x265;
});
x260;
});
x248.set_fs(x251);
return x250(x248, make_IntV(x256, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x168, immer::flex_vector<PtrVal> x169) {
FS x170 = x168.get_fs();
PtrVal x171 = x169.at(0);
int x172 = (int)proj_IntV(x171);
immer::map<int, Ptr<Stream>> x173 = x170.opened_files;
bool x174 = Map::contains(x173, x172);
immer::flex_vector<std::pair<SS, PtrVal>> x175 = !x174 ? ({
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(-1L, 64))};
}) : ({
PtrVal x176 = x169.at(1);
PtrVal x177 = x169.at(2);
int x178 = (int)proj_IntV(x177);
Ptr<Stream> x179 = x170.opened_files.at(x172);
immer::flex_vector<PtrVal> x180 = x168.at_seq(x176, x178).take((int)(int64_t)x178);
Ptr<File> x181 = x179->file;
int64_t x182 = x179->cursor;
// File.writeAt;
int x183 = (int)x182;
int x184 = x181->content.size();
int x185 = x183 - x184;
if (x185 > 0) {
immer::flex_vector<PtrVal> x186 = immer::flex_vector<PtrVal>(x185, IntV0);
immer::flex_vector<PtrVal> x187 = x181->content + x186;
x181->content = x187;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x188 = x181->content.take(x183);
immer::flex_vector<PtrVal> x189 = x188 + x180;
int x190 = x180.size();
immer::flex_vector<PtrVal> x191 = x181->content.drop(x183 + x190);
immer::flex_vector<PtrVal> x192 = x189 + x191;
x181->content = x192;
int64_t x193 = (int64_t)x190;
x179->cursor = x179->cursor + x193;
immer::map<int, Ptr<Stream>> x194 = x170.opened_files.insert(std::make_pair(x172, x179));
x170.opened_files = x194;
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(x193, 64))};
});
return x175;
}
inline std::monostate syscall_write(SS x195, immer::flex_vector<PtrVal> x196, std::function<std::monostate(SS, PtrVal)> x197) {
FS x198 = x195.get_fs();
PtrVal x199 = x196.at(0);
int x200 = (int)proj_IntV(x199);
immer::map<int, Ptr<Stream>> x201 = x198.opened_files;
bool x202 = Map::contains(x201, x200);
std::monostate x203 = !x202 ? ({
x195.set_fs(x198);
x197(x195, make_IntV(-1L, 64));
}) : ({
PtrVal x204 = x196.at(1);
PtrVal x205 = x196.at(2);
int x206 = (int)proj_IntV(x205);
Ptr<Stream> x207 = x198.opened_files.at(x200);
immer::flex_vector<PtrVal> x208 = x195.at_seq(x204, x206).take((int)(int64_t)x206);
Ptr<File> x209 = x207->file;
int64_t x210 = x207->cursor;
// File.writeAt;
int x211 = (int)x210;
int x212 = x209->content.size();
int x213 = x211 - x212;
if (x213 > 0) {
immer::flex_vector<PtrVal> x214 = immer::flex_vector<PtrVal>(x213, IntV0);
immer::flex_vector<PtrVal> x215 = x209->content + x214;
x209->content = x215;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x216 = x209->content.take(x211);
immer::flex_vector<PtrVal> x217 = x216 + x208;
int x218 = x208.size();
immer::flex_vector<PtrVal> x219 = x209->content.drop(x211 + x218);
immer::flex_vector<PtrVal> x220 = x217 + x219;
x209->content = x220;
int64_t x221 = (int64_t)x218;
x207->cursor = x207->cursor + x221;
immer::map<int, Ptr<Stream>> x222 = x198.opened_files.insert(std::make_pair(x200, x207));
x198.opened_files = x222;
x195.set_fs(x198);
x197(x195, make_IntV(x221, 64));
});
return x203;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x133, immer::flex_vector<PtrVal> x134) {
FS x135 = x133.get_fs();
PtrVal x136 = x134.at(0);
int x137 = (int)proj_IntV(x136);
immer::map<int, Ptr<Stream>> x138 = x135.opened_files;
bool x139 = Map::contains(x138, x137);
immer::flex_vector<std::pair<SS, PtrVal>> x140 = !x139 ? ({
x133.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x133, make_IntV(-1L, 64))};
}) : ({
PtrVal x141 = x134.at(1);
PtrVal x142 = x134.at(2);
Ptr<Stream> x143 = x135.opened_files.at(x137);
immer::flex_vector<PtrVal> x144 = x143->file->content.drop((int)x143->cursor);
immer::flex_vector<PtrVal> x145 = x144.take((int)(int64_t)(int)proj_IntV(x142));
int x146 = x145.size();
int64_t x147 = (int64_t)x146;
x143->cursor = x143->cursor + x147;
immer::map<int, Ptr<Stream>> x148 = x135.opened_files.insert(std::make_pair(x137, x143));
x135.opened_files = x148;
SS x149 = x133.update_seq(x141, x145);
x149.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x149, make_IntV(x147, 64))};
});
return x140;
}
inline std::monostate syscall_read(SS x150, immer::flex_vector<PtrVal> x151, std::function<std::monostate(SS, PtrVal)> x152) {
FS x153 = x150.get_fs();
PtrVal x154 = x151.at(0);
int x155 = (int)proj_IntV(x154);
immer::map<int, Ptr<Stream>> x156 = x153.opened_files;
bool x157 = Map::contains(x156, x155);
std::monostate x158 = !x157 ? ({
x150.set_fs(x153);
x152(x150, make_IntV(-1L, 64));
}) : ({
PtrVal x159 = x151.at(1);
PtrVal x160 = x151.at(2);
Ptr<Stream> x161 = x153.opened_files.at(x155);
immer::flex_vector<PtrVal> x162 = x161->file->content.drop((int)x161->cursor);
immer::flex_vector<PtrVal> x163 = x162.take((int)(int64_t)(int)proj_IntV(x160));
int x164 = x163.size();
int64_t x165 = (int64_t)x164;
x161->cursor = x161->cursor + x165;
immer::map<int, Ptr<Stream>> x166 = x153.opened_files.insert(std::make_pair(x155, x161));
x153.opened_files = x166;
SS x167 = x150.update_seq(x159, x163);
x167.set_fs(x153);
x152(x167, make_IntV(x165, 64));
});
return x158;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x58, immer::flex_vector<PtrVal> x59) {
FS x60 = x58.get_fs();
PtrVal x61 = x59.at(0);
int x62 = (int)proj_IntV(x61);
immer::map<int, Ptr<Stream>> x63 = x60.opened_files;
bool x64 = Map::contains(x63, x62);
immer::flex_vector<std::pair<SS, PtrVal>> x65 = !x64 ? ({
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(-1L, 32))};
}) : ({
Ptr<Stream> x66 = x60.opened_files.at(x62);
Ptr<File> x67 = x66->file;
/* getFile */;
Ptr<File> x68 = x60.root_file;
immer::flex_vector<String> x69 = Str::split(x67->name, "/");
immer::flex_vector<String> x70 = Vec::filter(x69, [&](auto x71) {
return x71.length() > 0;
});
Ptr<File> x72 = Vec::foldLeft(x70, x68, [&](auto x73, auto x74) {
bool x75 = x73 == nullptr || ({
bool x76 = Map::contains(x73->children, x74);
!x76;
});
Ptr<File> x77 = x75 ? nullptr : ({
Ptr<File> x78 = x73->children.at(x74);
x78;
});
return x77;
});
if (x72 != nullptr) {
Ptr<File> x79 = x66->file;
/* setFile */;
immer::flex_vector<String> x80 = Vec::filter(x69, [&](auto x81) {
return x81.length() > 0;
});
int x82 = x80.size();
immer::flex_vector<String> x83 = x80.take(x82 - 1);
Ptr<File> x84 = Vec::foldLeft(x83, x60.root_file, [&](auto x85, auto x86) {
bool x87 = x85 == nullptr || ({
bool x88 = Map::contains(x85->children, x86);
!x88;
});
Ptr<File> x89 = x87 ? nullptr : ({
Ptr<File> x90 = x85->children.at(x86);
x90;
});
return x89;
});
String x91 = x80.back();
String x92 = x79->name;
/* assertEq */;
ASSERT((x91 == x92), "setFile name should equal to last segment");
if (x84 != nullptr) {
immer::map<String, Ptr<File>> x93 = x84->children.insert(std::make_pair(x92, x79));
x84->children = x93;
}
immer::map<int, Ptr<Stream>> x94 = x60.opened_files.erase(x62);
x60.opened_files = x94;
}
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(0L, 32))};
});
return x65;
}
inline std::monostate syscall_close(SS x95, immer::flex_vector<PtrVal> x96, std::function<std::monostate(SS, PtrVal)> x97) {
FS x98 = x95.get_fs();
PtrVal x99 = x96.at(0);
int x100 = (int)proj_IntV(x99);
immer::map<int, Ptr<Stream>> x101 = x98.opened_files;
bool x102 = Map::contains(x101, x100);
std::monostate x103 = !x102 ? ({
x95.set_fs(x98);
x97(x95, make_IntV(-1L, 32));
}) : ({
Ptr<Stream> x104 = x98.opened_files.at(x100);
Ptr<File> x105 = x104->file;
/* getFile */;
Ptr<File> x106 = x98.root_file;
immer::flex_vector<String> x107 = Str::split(x105->name, "/");
immer::flex_vector<String> x108 = Vec::filter(x107, [&](auto x109) {
return x109.length() > 0;
});
Ptr<File> x110 = Vec::foldLeft(x108, x106, [&](auto x111, auto x112) {
bool x113 = x111 == nullptr || ({
bool x114 = Map::contains(x111->children, x112);
!x114;
});
Ptr<File> x115 = x113 ? nullptr : ({
Ptr<File> x116 = x111->children.at(x112);
x116;
});
return x115;
});
if (x110 != nullptr) {
Ptr<File> x117 = x104->file;
/* setFile */;
immer::flex_vector<String> x118 = Vec::filter(x107, [&](auto x119) {
return x119.length() > 0;
});
int x120 = x118.size();
immer::flex_vector<String> x121 = x118.take(x120 - 1);
Ptr<File> x122 = Vec::foldLeft(x121, x98.root_file, [&](auto x123, auto x124) {
bool x125 = x123 == nullptr || ({
bool x126 = Map::contains(x123->children, x124);
!x126;
});
Ptr<File> x127 = x125 ? nullptr : ({
Ptr<File> x128 = x123->children.at(x124);
x128;
});
return x127;
});
String x129 = x118.back();
String x130 = x117->name;
/* assertEq */;
ASSERT((x129 == x130), "setFile name should equal to last segment");
if (x122 != nullptr) {
immer::map<String, Ptr<File>> x131 = x122->children.insert(std::make_pair(x130, x117));
x122->children = x131;
}
immer::map<int, Ptr<Stream>> x132 = x98.opened_files.erase(x100);
x98.opened_files = x132;
}
x95.set_fs(x98);
x97(x95, make_IntV(0L, 32));
});
return x103;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
/* getFile */;
Ptr<File> x5 = x3.root_file;
immer::flex_vector<String> x6 = Str::split(get_string(x4, x1), "/");
immer::flex_vector<String> x7 = Vec::filter(x6, [&](auto x8) {
return x8.length() > 0;
});
Ptr<File> x9 = Vec::foldLeft(x7, x5, [&](auto x10, auto x11) {
bool x12 = x10 == nullptr || ({
bool x13 = Map::contains(x10->children, x11);
!x13;
});
Ptr<File> x14 = x12 ? nullptr : ({
Ptr<File> x15 = x10->children.at(x11);
x15;
});
return x14;
});
immer::flex_vector<std::pair<SS, PtrVal>> x16 = !(x9 != nullptr) ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x17 = x3.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x18 = Vec::filter(x6, [&](auto x19) {
return x19.length() > 0;
});
Ptr<File> x20 = Vec::foldLeft(x18, x3.root_file, [&](auto x21, auto x22) {
bool x23 = x21 == nullptr || ({
bool x24 = Map::contains(x21->children, x22);
!x24;
});
Ptr<File> x25 = x23 ? nullptr : ({
Ptr<File> x26 = x21->children.at(x22);
x26;
});
return x25;
});
Ptr<Stream> x27 = Stream::create(x20);
immer::map<int, Ptr<Stream>> x28 = x3.opened_files.insert(std::make_pair(x17, x27));
x3.opened_files = x28;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x17, 32))};
});
return x16;
}
inline std::monostate syscall_open(SS x29, immer::flex_vector<PtrVal> x30, std::function<std::monostate(SS, PtrVal)> x31) {
FS x32 = x29.get_fs();
PtrVal x33 = x30.at(0);
/* getFile */;
Ptr<File> x34 = x32.root_file;
immer::flex_vector<String> x35 = Str::split(get_string(x33, x29), "/");
immer::flex_vector<String> x36 = Vec::filter(x35, [&](auto x37) {
return x37.length() > 0;
});
Ptr<File> x38 = Vec::foldLeft(x36, x34, [&](auto x39, auto x40) {
bool x41 = x39 == nullptr || ({
bool x42 = Map::contains(x39->children, x40);
!x42;
});
Ptr<File> x43 = x41 ? nullptr : ({
Ptr<File> x44 = x39->children.at(x40);
x44;
});
return x43;
});
std::monostate x45 = !(x38 != nullptr) ? ({
x29.set_fs(x32);
x31(x29, make_IntV(-1L, 32));
}) : ({
int x46 = x32.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x47 = Vec::filter(x35, [&](auto x48) {
return x48.length() > 0;
});
Ptr<File> x49 = Vec::foldLeft(x47, x32.root_file, [&](auto x50, auto x51) {
bool x52 = x50 == nullptr || ({
bool x53 = Map::contains(x50->children, x51);
!x53;
});
Ptr<File> x54 = x52 ? nullptr : ({
Ptr<File> x55 = x50->children.at(x51);
x55;
});
return x54;
});
Ptr<Stream> x56 = Stream::create(x49);
immer::map<int, Ptr<Stream>> x57 = x32.opened_files.insert(std::make_pair(x46, x56));
x32.opened_files = x57;
x29.set_fs(x32);
x31(x29, make_IntV((int64_t)x46, 32));
});
return x45;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
