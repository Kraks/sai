/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> open(SS, immer::flex_vector<PtrVal>);
std::monostate open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> close(SS, immer::flex_vector<PtrVal>);
std::monostate close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> read(SS, immer::flex_vector<PtrVal>);
std::monostate read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> write(SS, immer::flex_vector<PtrVal>);
std::monostate write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> lseek(SS, immer::flex_vector<PtrVal>);
std::monostate lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> stat(SS, immer::flex_vector<PtrVal>);
std::monostate stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);

/************* Functions **************/
inline immer::flex_vector<std::pair<SS, PtrVal>> stat(SS x98, immer::flex_vector<PtrVal> x99) {
PtrVal x100 = x99.at(0);
FS x101 = x98.get_fs();
std::pair<immer::flex_vector<PtrVal>, int> x102 = x101.stat_file(get_string(x100, x98));
int x103 = std::get<1>(x102);
immer::flex_vector<std::pair<SS, PtrVal>> x104 = x103 == 0 ? ({
PtrVal x105 = x99.at(1);
SS x106 = x98.update_seq(x105, std::get<0>(x102));
x106.set_fs(x101);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x106, make_IntV((int64_t)x103, 32))};
}) : immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x98, make_IntV((int64_t)x103, 32))};
return x104;
}
inline std::monostate stat(SS x107, immer::flex_vector<PtrVal> x108, std::function<std::monostate(SS, PtrVal)> x109) {
PtrVal x110 = x108.at(0);
FS x111 = x107.get_fs();
std::pair<immer::flex_vector<PtrVal>, int> x112 = x111.stat_file(get_string(x110, x107));
int x113 = std::get<1>(x112);
std::monostate x114 = x113 == 0 ? ({
PtrVal x115 = x108.at(1);
SS x116 = x107.update_seq(x115, std::get<0>(x112));
x116.set_fs(x111);
x109(x116, make_IntV((int64_t)x113, 32));
}) : x109(x107, make_IntV((int64_t)x113, 32));
return x114;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> lseek(SS x83, immer::flex_vector<PtrVal> x84) {
PtrVal x85 = x84.at(0);
PtrVal x86 = x84.at(1);
PtrVal x87 = x84.at(2);
FS x88 = x83.get_fs();
int64_t x89 = x88.seek_file((int64_t)proj_IntV(x85), (int64_t)proj_IntV(x86), (int64_t)proj_IntV(x87));
x83.set_fs(x88);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x83, make_IntV(x89, 64))};
}
inline std::monostate lseek(SS x90, immer::flex_vector<PtrVal> x91, std::function<std::monostate(SS, PtrVal)> x92) {
PtrVal x93 = x91.at(0);
PtrVal x94 = x91.at(1);
PtrVal x95 = x91.at(2);
FS x96 = x90.get_fs();
int64_t x97 = x96.seek_file((int64_t)proj_IntV(x93), (int64_t)proj_IntV(x94), (int64_t)proj_IntV(x95));
x90.set_fs(x96);
return x92(x90, make_IntV(x97, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> write(SS x66, immer::flex_vector<PtrVal> x67) {
PtrVal x68 = x67.at(0);
PtrVal x69 = x67.at(1);
PtrVal x70 = x67.at(2);
int64_t x71 = (int64_t)proj_IntV(x70);
FS x72 = x66.get_fs();
int x73 = x72.write_file((int64_t)proj_IntV(x68), x66.at_seq(x69, x71), x71);
x66.set_fs(x72);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x66, make_IntV((int64_t)x73, 64))};
}
inline std::monostate write(SS x74, immer::flex_vector<PtrVal> x75, std::function<std::monostate(SS, PtrVal)> x76) {
PtrVal x77 = x75.at(0);
PtrVal x78 = x75.at(1);
PtrVal x79 = x75.at(2);
int64_t x80 = (int64_t)proj_IntV(x79);
FS x81 = x74.get_fs();
int x82 = x81.write_file((int64_t)proj_IntV(x77), x74.at_seq(x78, x80), x80);
x74.set_fs(x81);
return x76(x74, make_IntV((int64_t)x82, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> read(SS x39, immer::flex_vector<PtrVal> x40) {
PtrVal x41 = x40.at(0);
int64_t x42 = (int64_t)proj_IntV(x41);
FS x43 = x39.get_fs();
bool x44 = x43.has_stream(x42);
immer::flex_vector<std::pair<SS, PtrVal>> x45 = !x44 ? immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x39, make_IntV(-1L, 32))} : ({
PtrVal x46 = x40.at(1);
PtrVal x47 = x40.at(2);
Stream x48 = x43.get_stream(x42);
immer::flex_vector<PtrVal> x49 = x48.read((int64_t)proj_IntV(x47));
x43.set_stream(x42, x48);
int x50 = x49.size();
SS x51 = x39.update_seq(x46, x49);
x51.set_fs(x43);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x51, make_IntV((int64_t)x50, 64))};
});
return x45;
}
inline std::monostate read(SS x52, immer::flex_vector<PtrVal> x53, std::function<std::monostate(SS, PtrVal)> x54) {
PtrVal x55 = x53.at(0);
int64_t x56 = (int64_t)proj_IntV(x55);
FS x57 = x52.get_fs();
bool x58 = x57.has_stream(x56);
std::monostate x59 = !x58 ? x54(x52, make_IntV(-1L, 32)) : ({
PtrVal x60 = x53.at(1);
PtrVal x61 = x53.at(2);
Stream x62 = x57.get_stream(x56);
immer::flex_vector<PtrVal> x63 = x62.read((int64_t)proj_IntV(x61));
x57.set_stream(x56, x62);
int x64 = x63.size();
SS x65 = x52.update_seq(x60, x63);
x65.set_fs(x57);
x54(x65, make_IntV((int64_t)x64, 64));
});
return x59;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> close(SS x18, immer::flex_vector<PtrVal> x19) {
PtrVal x20 = x19.at(0);
int64_t x21 = (int64_t)proj_IntV(x20->to_IntV());
FS x22 = x18.get_fs();
bool x23 = x22.has_stream(x21);
immer::flex_vector<std::pair<SS, PtrVal>> x24 = !x23 ? immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x18, make_IntV(-1L, 32))} : ({
Stream x25 = x22.get_stream(x21);
String x26 = x25.get_name();
bool x27 = x22.has_file(x26);
if (x27) {
x22.set_file(x26, x25.get_file());
x22.remove_stream(x21);
}
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x18, make_IntV(0L, 32))};
});
return x24;
}
inline std::monostate close(SS x28, immer::flex_vector<PtrVal> x29, std::function<std::monostate(SS, PtrVal)> x30) {
PtrVal x31 = x29.at(0);
int64_t x32 = (int64_t)proj_IntV(x31->to_IntV());
FS x33 = x28.get_fs();
bool x34 = x33.has_stream(x32);
std::monostate x35 = !x34 ? x30(x28, make_IntV(-1L, 32)) : ({
Stream x36 = x33.get_stream(x32);
String x37 = x36.get_name();
bool x38 = x33.has_file(x37);
if (x38) {
x33.set_file(x37, x36.get_file());
x33.remove_stream(x32);
}
x30(x28, make_IntV(0L, 32));
});
return x35;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> open(SS x1, immer::flex_vector<PtrVal> x2) {
PtrVal x3 = x2.at(0);
String x4 = get_string(x3, x1);
FS x5 = x1.get_fs();
bool x6 = x5.has_file(x4);
immer::flex_vector<std::pair<SS, PtrVal>> x7 = !x6 ? immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))} : ({
int x8 = x5.get_fresh_fd();
x5.set_stream(x8, Stream(x5.get_file(x4)));
x1.set_fs(x5);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x8, 32))};
});
return x7;
}
inline std::monostate open(SS x9, immer::flex_vector<PtrVal> x10, std::function<std::monostate(SS, PtrVal)> x11) {
PtrVal x12 = x10.at(0);
String x13 = get_string(x12, x9);
FS x14 = x9.get_fs();
bool x15 = x14.has_file(x13);
std::monostate x16 = !x15 ? x11(x9, make_IntV(-1L, 32)) : ({
int x17 = x14.get_fresh_fd();
x14.set_stream(x17, Stream(x14.get_file(x13)));
x9.set_fs(x14);
x11(x9, make_IntV((int64_t)x17, 32));
});
return x16;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
