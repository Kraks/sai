/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);

/************* Functions **************/
inline FS set_file(FS x187, String x188, Ptr<File> x189) {
Ptr<File> x190 = x187.root_file;
immer::map<String, Ptr<File>> x191 = x190->children.insert(std::make_pair(x188, x189));
x190->children = x191;
return x187;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x164, immer::flex_vector<PtrVal> x165) {
FS x166 = x164.get_fs();
PtrVal x167 = x165.at(0);
String x168 = get_string(x167, x164);
Ptr<File> x169 = x166.root_file;
bool x170 = Map::contains(x169->children, x168);
immer::flex_vector<std::pair<SS, PtrVal>> x171 = !x170 ? ({
x164.set_fs(x166);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x164, make_IntV(-1L, 32))};
}) : ({
PtrVal x172 = x165.at(1);
Ptr<File> x173 = x166.root_file->children.at(x168);
SS x174 = x164.update_seq(x172, x173->stat);
x174.set_fs(x166);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x174, make_IntV(0L, 32))};
});
return x171;
}
inline std::monostate syscall_stat(SS x175, immer::flex_vector<PtrVal> x176, std::function<std::monostate(SS, PtrVal)> x177) {
FS x178 = x175.get_fs();
PtrVal x179 = x176.at(0);
String x180 = get_string(x179, x175);
Ptr<File> x181 = x178.root_file;
bool x182 = Map::contains(x181->children, x180);
std::monostate x183 = !x182 ? ({
x175.set_fs(x178);
x177(x175, make_IntV(-1L, 32));
}) : ({
PtrVal x184 = x176.at(1);
Ptr<File> x185 = x178.root_file->children.at(x180);
SS x186 = x175.update_seq(x184, x185->stat);
x186.set_fs(x178);
x177(x186, make_IntV(0L, 32));
});
return x183;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x149, immer::flex_vector<PtrVal> x150) {
FS x151 = x149.get_fs();
PtrVal x152 = x150.at(0);
PtrVal x153 = x150.at(1);
PtrVal x154 = x150.at(2);
int64_t x155 = x151.seek_file(proj_IntV(x152), proj_IntV(x153), (int)proj_IntV(x154));
x149.set_fs(x151);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x149, make_IntV(x155, 64))};
}
inline std::monostate syscall_lseek(SS x156, immer::flex_vector<PtrVal> x157, std::function<std::monostate(SS, PtrVal)> x158) {
FS x159 = x156.get_fs();
PtrVal x160 = x157.at(0);
PtrVal x161 = x157.at(1);
PtrVal x162 = x157.at(2);
int64_t x163 = x159.seek_file(proj_IntV(x160), proj_IntV(x161), (int)proj_IntV(x162));
x156.set_fs(x159);
return x158(x156, make_IntV(x163, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x94, immer::flex_vector<PtrVal> x95) {
FS x96 = x94.get_fs();
PtrVal x97 = x95.at(0);
int x98 = (int)proj_IntV(x97);
immer::map<int, Stream> x99 = x96.opened_files;
bool x100 = Map::contains(x99, x98);
immer::flex_vector<std::pair<SS, PtrVal>> x101 = !x100 ? ({
x94.set_fs(x96);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x94, make_IntV(-1L, 64))};
}) : ({
PtrVal x102 = x95.at(1);
PtrVal x103 = x95.at(2);
int x104 = (int)proj_IntV(x103);
Stream x105 = x96.opened_files.at(x98);
immer::flex_vector<PtrVal> x106 = x94.at_seq(x102, x104).take((int)(int64_t)x104);
Ptr<File> x107 = x105.file;
int64_t x108 = x105.cursor;
// File.writeAt;
int x109 = (int)x108;
int x110 = x107->content.size();
int x111 = x109 - x110;
if (x111 > 0) {
immer::flex_vector<PtrVal> x112 = immer::flex_vector<PtrVal>(x111, IntV0);
immer::flex_vector<PtrVal> x113 = x107->content + x112;
x107->content = x113;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x114 = x107->content.take(x109);
immer::flex_vector<PtrVal> x115 = x114 + x106;
int x116 = x106.size();
immer::flex_vector<PtrVal> x117 = x107->content.drop(x109 + x116);
immer::flex_vector<PtrVal> x118 = x115 + x117;
x107->content = x118;
x105.file = x107;
int64_t x119 = (int64_t)x116;
x105.cursor = x108 + x119;
immer::map<int, Stream> x120 = x96.opened_files.insert(std::make_pair(x98, x105));
x96.opened_files = x120;
x94.set_fs(x96);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x94, make_IntV(x119, 64))};
});
return x101;
}
inline std::monostate syscall_write(SS x121, immer::flex_vector<PtrVal> x122, std::function<std::monostate(SS, PtrVal)> x123) {
FS x124 = x121.get_fs();
PtrVal x125 = x122.at(0);
int x126 = (int)proj_IntV(x125);
immer::map<int, Stream> x127 = x124.opened_files;
bool x128 = Map::contains(x127, x126);
std::monostate x129 = !x128 ? ({
x121.set_fs(x124);
x123(x121, make_IntV(-1L, 64));
}) : ({
PtrVal x130 = x122.at(1);
PtrVal x131 = x122.at(2);
int x132 = (int)proj_IntV(x131);
Stream x133 = x124.opened_files.at(x126);
immer::flex_vector<PtrVal> x134 = x121.at_seq(x130, x132).take((int)(int64_t)x132);
Ptr<File> x135 = x133.file;
int64_t x136 = x133.cursor;
// File.writeAt;
int x137 = (int)x136;
int x138 = x135->content.size();
int x139 = x137 - x138;
if (x139 > 0) {
immer::flex_vector<PtrVal> x140 = immer::flex_vector<PtrVal>(x139, IntV0);
immer::flex_vector<PtrVal> x141 = x135->content + x140;
x135->content = x141;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x142 = x135->content.take(x137);
immer::flex_vector<PtrVal> x143 = x142 + x134;
int x144 = x134.size();
immer::flex_vector<PtrVal> x145 = x135->content.drop(x137 + x144);
immer::flex_vector<PtrVal> x146 = x143 + x145;
x135->content = x146;
x133.file = x135;
int64_t x147 = (int64_t)x144;
x133.cursor = x136 + x147;
immer::map<int, Stream> x148 = x124.opened_files.insert(std::make_pair(x126, x133));
x124.opened_files = x148;
x121.set_fs(x124);
x123(x121, make_IntV(x147, 64));
});
return x129;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x57, immer::flex_vector<PtrVal> x58) {
FS x59 = x57.get_fs();
PtrVal x60 = x58.at(0);
int x61 = (int)proj_IntV(x60);
immer::map<int, Stream> x62 = x59.opened_files;
bool x63 = Map::contains(x62, x61);
immer::flex_vector<std::pair<SS, PtrVal>> x64 = !x63 ? ({
x57.set_fs(x59);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x57, make_IntV(-1L, 64))};
}) : ({
PtrVal x65 = x58.at(1);
PtrVal x66 = x58.at(2);
Stream x67 = x59.opened_files.at(x61);
int64_t x68 = x67.cursor;
immer::flex_vector<PtrVal> x69 = x67.file->content.drop((int)x68);
immer::flex_vector<PtrVal> x70 = x69.take((int)(int64_t)(int)proj_IntV(x66));
int x71 = x70.size();
int64_t x72 = (int64_t)x71;
x67.cursor = x68 + x72;
immer::map<int, Stream> x73 = x59.opened_files.insert(std::make_pair(x61, x67));
x59.opened_files = x73;
SS x74 = x57.update_seq(x65, x70);
x74.set_fs(x59);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x74, make_IntV(x72, 64))};
});
return x64;
}
inline std::monostate syscall_read(SS x75, immer::flex_vector<PtrVal> x76, std::function<std::monostate(SS, PtrVal)> x77) {
FS x78 = x75.get_fs();
PtrVal x79 = x76.at(0);
int x80 = (int)proj_IntV(x79);
immer::map<int, Stream> x81 = x78.opened_files;
bool x82 = Map::contains(x81, x80);
std::monostate x83 = !x82 ? ({
x75.set_fs(x78);
x77(x75, make_IntV(-1L, 64));
}) : ({
PtrVal x84 = x76.at(1);
PtrVal x85 = x76.at(2);
Stream x86 = x78.opened_files.at(x80);
int64_t x87 = x86.cursor;
immer::flex_vector<PtrVal> x88 = x86.file->content.drop((int)x87);
immer::flex_vector<PtrVal> x89 = x88.take((int)(int64_t)(int)proj_IntV(x85));
int x90 = x89.size();
int64_t x91 = (int64_t)x90;
x86.cursor = x87 + x91;
immer::map<int, Stream> x92 = x78.opened_files.insert(std::make_pair(x80, x86));
x78.opened_files = x92;
SS x93 = x75.update_seq(x84, x89);
x93.set_fs(x78);
x77(x93, make_IntV(x91, 64));
});
return x83;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x24, immer::flex_vector<PtrVal> x25) {
FS x26 = x24.get_fs();
PtrVal x27 = x25.at(0);
int x28 = (int)proj_IntV(x27);
immer::map<int, Stream> x29 = x26.opened_files;
bool x30 = Map::contains(x29, x28);
immer::flex_vector<std::pair<SS, PtrVal>> x31 = !x30 ? ({
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(-1L, 32))};
}) : ({
Stream x32 = x26.opened_files.at(x28);
Ptr<File> x33 = x32.file;
String x34 = x33->name;
Ptr<File> x35 = x26.root_file;
bool x36 = Map::contains(x35->children, x34);
if (x36) {
Ptr<File> x37 = x26.root_file;
immer::map<String, Ptr<File>> x38 = x37->children.insert(std::make_pair(x34, x33));
x37->children = x38;
immer::map<int, Stream> x39 = x26.opened_files.erase(x28);
x26.opened_files = x39;
}
x24.set_fs(x26);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x24, make_IntV(0L, 32))};
});
return x31;
}
inline std::monostate syscall_close(SS x40, immer::flex_vector<PtrVal> x41, std::function<std::monostate(SS, PtrVal)> x42) {
FS x43 = x40.get_fs();
PtrVal x44 = x41.at(0);
int x45 = (int)proj_IntV(x44);
immer::map<int, Stream> x46 = x43.opened_files;
bool x47 = Map::contains(x46, x45);
std::monostate x48 = !x47 ? ({
x40.set_fs(x43);
x42(x40, make_IntV(-1L, 32));
}) : ({
Stream x49 = x43.opened_files.at(x45);
Ptr<File> x50 = x49.file;
String x51 = x50->name;
Ptr<File> x52 = x43.root_file;
bool x53 = Map::contains(x52->children, x51);
if (x53) {
Ptr<File> x54 = x43.root_file;
immer::map<String, Ptr<File>> x55 = x54->children.insert(std::make_pair(x51, x50));
x54->children = x55;
immer::map<int, Stream> x56 = x43.opened_files.erase(x45);
x43.opened_files = x56;
}
x40.set_fs(x43);
x42(x40, make_IntV(0L, 32));
});
return x48;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
String x5 = get_string(x4, x1);
Ptr<File> x6 = x3.root_file;
bool x7 = Map::contains(x6->children, x5);
immer::flex_vector<std::pair<SS, PtrVal>> x8 = !x7 ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x9 = x3.get_fresh_fd();
Ptr<File> x10 = x3.root_file->children.at(x5);
immer::map<int, Stream> x11 = x3.opened_files.insert(std::make_pair(x9, Stream(x10)));
x3.opened_files = x11;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x9, 32))};
});
return x8;
}
inline std::monostate syscall_open(SS x12, immer::flex_vector<PtrVal> x13, std::function<std::monostate(SS, PtrVal)> x14) {
FS x15 = x12.get_fs();
PtrVal x16 = x13.at(0);
String x17 = get_string(x16, x12);
Ptr<File> x18 = x15.root_file;
bool x19 = Map::contains(x18->children, x17);
std::monostate x20 = !x19 ? ({
x12.set_fs(x15);
x14(x12, make_IntV(-1L, 32));
}) : ({
int x21 = x15.get_fresh_fd();
Ptr<File> x22 = x15.root_file->children.at(x17);
immer::map<int, Stream> x23 = x15.opened_files.insert(std::make_pair(x21, Stream(x22)));
x15.opened_files = x23;
x12.set_fs(x15);
x14(x12, make_IntV((int64_t)x21, 32));
});
return x20;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
