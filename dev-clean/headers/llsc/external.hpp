/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_mkdir(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_mkdir(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);
Ptr<File> set_file_type(Ptr<File>, int);
bool has_file_type(Ptr<File>, int);

/************* Functions **************/
inline bool has_file_type(Ptr<File> x443, int x444) {
immer::flex_vector<PtrVal> x445 = x443->stat.drop(24);
immer::flex_vector<PtrVal> x446 = x445.take(4);
return (bool)(proj_IntV(Value::from_bytes(x446)) & (int64_t)x444);
}
inline Ptr<File> set_file_type(Ptr<File> x433, int x434) {
/* _set_file_type */;
immer::flex_vector<PtrVal> x435 = x433->stat.drop(24);
immer::flex_vector<PtrVal> x436 = x435.take(4);
immer::flex_vector<PtrVal> x437 = make_IntV(proj_IntV(Value::from_bytes(x436)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)x434, 32)->to_bytes();
immer::flex_vector<PtrVal> x438 = x433->stat.take(24);
immer::flex_vector<PtrVal> x439 = x438 + x437;
int x440 = x437.size();
immer::flex_vector<PtrVal> x441 = x433->stat.drop(24 + x440);
immer::flex_vector<PtrVal> x442 = x439 + x441;
x433->stat = x442;
return x433;
}
inline FS set_file(FS x416, String x417, Ptr<File> x418) {
/* setFile */;
immer::flex_vector<String> x419 = Vec::filter(Str::split(x417, "/"), [&](auto x420) {
return x420.length() > 0;
});
int x421 = x419.size();
immer::flex_vector<String> x422 = x419.take(x421 - 1);
Ptr<File> x423 = Vec::foldLeft(x422, x416.root_file, [&](auto x424, auto x425) {
bool x426 = x424 == nullptr || ({
bool x427 = Map::contains(x424->children, x425);
!x427;
});
Ptr<File> x428 = x426 ? nullptr : ({
Ptr<File> x429 = x424->children.at(x425);
x429;
});
return x428;
});
String x430 = x419.back();
String x431 = x418->name;
/* assertEq */;
ASSERT((x430 == x431), "setFile name should equal to last segment");
if (x423 != nullptr) {
immer::map<String, Ptr<File>> x432 = x423->children.insert(std::make_pair(x431, x418));
x423->children = x432;
}
return x416;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_mkdir(SS x329, immer::flex_vector<PtrVal> x330) {
FS x331 = x329.get_fs();
PtrVal x332 = x330.at(0);
immer::flex_vector<String> x333 = Str::split(get_string(x332, x329), "/");
/* getFile */;
Ptr<File> x334 = x331.root_file;
immer::flex_vector<String> x335 = Vec::filter(x333, [&](auto x336) {
return x336.length() > 0;
});
Ptr<File> x337 = Vec::foldLeft(x335, x334, [&](auto x338, auto x339) {
bool x340 = x338 == nullptr || ({
bool x341 = Map::contains(x338->children, x339);
!x341;
});
Ptr<File> x342 = x340 ? nullptr : ({
Ptr<File> x343 = x338->children.at(x339);
x343;
});
return x342;
});
immer::flex_vector<std::pair<SS, PtrVal>> x344 = x337 != nullptr ? ({
x329.set_fs(x331);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x329, make_IntV(-1L, 32))};
}) : ({
immer::flex_vector<String> x345 = Vec::filter(x333, [&](auto x346) {
return x346.length() > 0;
});
String x347 = x345.back();
immer::flex_vector<PtrVal> x348 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x349 = File::create(x347, immer::flex_vector<PtrVal>{}, x348);
/* _set_file_type */;
immer::flex_vector<PtrVal> x350 = x349->stat.drop(24);
immer::flex_vector<PtrVal> x351 = x350.take(4);
immer::flex_vector<PtrVal> x352 = make_IntV(proj_IntV(Value::from_bytes(x351)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFDIR, 32)->to_bytes();
immer::flex_vector<PtrVal> x353 = x349->stat.take(24);
immer::flex_vector<PtrVal> x354 = x353 + x352;
int x355 = x352.size();
immer::flex_vector<PtrVal> x356 = x349->stat.drop(24 + x355);
immer::flex_vector<PtrVal> x357 = x354 + x356;
x349->stat = x357;
/* mkdir: fs.setFile */;
/* setFile */;
immer::flex_vector<String> x358 = Vec::filter(x333, [&](auto x359) {
return x359.length() > 0;
});
int x360 = x358.size();
immer::flex_vector<String> x361 = x358.take(x360 - 1);
Ptr<File> x362 = Vec::foldLeft(x361, x331.root_file, [&](auto x363, auto x364) {
bool x365 = x363 == nullptr || ({
bool x366 = Map::contains(x363->children, x364);
!x366;
});
Ptr<File> x367 = x365 ? nullptr : ({
Ptr<File> x368 = x363->children.at(x364);
x368;
});
return x367;
});
String x369 = x358.back();
String x370 = x349->name;
/* assertEq */;
ASSERT((x369 == x370), "setFile name should equal to last segment");
if (x362 != nullptr) {
immer::map<String, Ptr<File>> x371 = x362->children.insert(std::make_pair(x370, x349));
x362->children = x371;
}
/* mkdir: return */;
x329.set_fs(x331);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x329, make_IntV(0L, 32))};
});
return x344;
}
inline std::monostate syscall_mkdir(SS x372, immer::flex_vector<PtrVal> x373, std::function<std::monostate(SS, PtrVal)> x374) {
FS x375 = x372.get_fs();
PtrVal x376 = x373.at(0);
immer::flex_vector<String> x377 = Str::split(get_string(x376, x372), "/");
/* getFile */;
Ptr<File> x378 = x375.root_file;
immer::flex_vector<String> x379 = Vec::filter(x377, [&](auto x380) {
return x380.length() > 0;
});
Ptr<File> x381 = Vec::foldLeft(x379, x378, [&](auto x382, auto x383) {
bool x384 = x382 == nullptr || ({
bool x385 = Map::contains(x382->children, x383);
!x385;
});
Ptr<File> x386 = x384 ? nullptr : ({
Ptr<File> x387 = x382->children.at(x383);
x387;
});
return x386;
});
std::monostate x388 = x381 != nullptr ? ({
x372.set_fs(x375);
x374(x372, make_IntV(-1L, 32));
}) : ({
immer::flex_vector<String> x389 = Vec::filter(x377, [&](auto x390) {
return x390.length() > 0;
});
String x391 = x389.back();
immer::flex_vector<PtrVal> x392 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x393 = File::create(x391, immer::flex_vector<PtrVal>{}, x392);
/* _set_file_type */;
immer::flex_vector<PtrVal> x394 = x393->stat.drop(24);
immer::flex_vector<PtrVal> x395 = x394.take(4);
immer::flex_vector<PtrVal> x396 = make_IntV(proj_IntV(Value::from_bytes(x395)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFDIR, 32)->to_bytes();
immer::flex_vector<PtrVal> x397 = x393->stat.take(24);
immer::flex_vector<PtrVal> x398 = x397 + x396;
int x399 = x396.size();
immer::flex_vector<PtrVal> x400 = x393->stat.drop(24 + x399);
immer::flex_vector<PtrVal> x401 = x398 + x400;
x393->stat = x401;
/* mkdir: fs.setFile */;
/* setFile */;
immer::flex_vector<String> x402 = Vec::filter(x377, [&](auto x403) {
return x403.length() > 0;
});
int x404 = x402.size();
immer::flex_vector<String> x405 = x402.take(x404 - 1);
Ptr<File> x406 = Vec::foldLeft(x405, x375.root_file, [&](auto x407, auto x408) {
bool x409 = x407 == nullptr || ({
bool x410 = Map::contains(x407->children, x408);
!x410;
});
Ptr<File> x411 = x409 ? nullptr : ({
Ptr<File> x412 = x407->children.at(x408);
x412;
});
return x411;
});
String x413 = x402.back();
String x414 = x393->name;
/* assertEq */;
ASSERT((x413 == x414), "setFile name should equal to last segment");
if (x406 != nullptr) {
immer::map<String, Ptr<File>> x415 = x406->children.insert(std::make_pair(x414, x393));
x406->children = x415;
}
/* mkdir: return */;
x372.set_fs(x375);
x374(x372, make_IntV(0L, 32));
});
return x388;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x274, immer::flex_vector<PtrVal> x275) {
FS x276 = x274.get_fs();
PtrVal x277 = x275.at(0);
/* getFile */;
Ptr<File> x278 = x276.root_file;
immer::flex_vector<String> x279 = Str::split(get_string(x277, x274), "/");
immer::flex_vector<String> x280 = Vec::filter(x279, [&](auto x281) {
return x281.length() > 0;
});
Ptr<File> x282 = Vec::foldLeft(x280, x278, [&](auto x283, auto x284) {
bool x285 = x283 == nullptr || ({
bool x286 = Map::contains(x283->children, x284);
!x286;
});
Ptr<File> x287 = x285 ? nullptr : ({
Ptr<File> x288 = x283->children.at(x284);
x288;
});
return x287;
});
immer::flex_vector<std::pair<SS, PtrVal>> x289 = !(x282 != nullptr) ? ({
x274.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x274, make_IntV(-1L, 32))};
}) : ({
PtrVal x290 = x275.at(1);
/* getFile */;
immer::flex_vector<String> x291 = Vec::filter(x279, [&](auto x292) {
return x292.length() > 0;
});
Ptr<File> x293 = Vec::foldLeft(x291, x276.root_file, [&](auto x294, auto x295) {
bool x296 = x294 == nullptr || ({
bool x297 = Map::contains(x294->children, x295);
!x297;
});
Ptr<File> x298 = x296 ? nullptr : ({
Ptr<File> x299 = x294->children.at(x295);
x299;
});
return x298;
});
SS x300 = x274.update_seq(x290, x293->stat);
x300.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x300, make_IntV(0L, 32))};
});
return x289;
}
inline std::monostate syscall_stat(SS x301, immer::flex_vector<PtrVal> x302, std::function<std::monostate(SS, PtrVal)> x303) {
FS x304 = x301.get_fs();
PtrVal x305 = x302.at(0);
/* getFile */;
Ptr<File> x306 = x304.root_file;
immer::flex_vector<String> x307 = Str::split(get_string(x305, x301), "/");
immer::flex_vector<String> x308 = Vec::filter(x307, [&](auto x309) {
return x309.length() > 0;
});
Ptr<File> x310 = Vec::foldLeft(x308, x306, [&](auto x311, auto x312) {
bool x313 = x311 == nullptr || ({
bool x314 = Map::contains(x311->children, x312);
!x314;
});
Ptr<File> x315 = x313 ? nullptr : ({
Ptr<File> x316 = x311->children.at(x312);
x316;
});
return x315;
});
std::monostate x317 = !(x310 != nullptr) ? ({
x301.set_fs(x304);
x303(x301, make_IntV(-1L, 32));
}) : ({
PtrVal x318 = x302.at(1);
/* getFile */;
immer::flex_vector<String> x319 = Vec::filter(x307, [&](auto x320) {
return x320.length() > 0;
});
Ptr<File> x321 = Vec::foldLeft(x319, x304.root_file, [&](auto x322, auto x323) {
bool x324 = x322 == nullptr || ({
bool x325 = Map::contains(x322->children, x323);
!x325;
});
Ptr<File> x326 = x324 ? nullptr : ({
Ptr<File> x327 = x322->children.at(x323);
x327;
});
return x326;
});
SS x328 = x301.update_seq(x318, x321->stat);
x328.set_fs(x304);
x303(x328, make_IntV(0L, 32));
});
return x317;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x223, immer::flex_vector<PtrVal> x224) {
FS x225 = x223.get_fs();
PtrVal x226 = x224.at(0);
int x227 = (int)proj_IntV(x226);
immer::map<int, Ptr<Stream>> x228 = x225.opened_files;
bool x229 = Map::contains(x228, x227);
int64_t x230 = !x229 ? -1L : ({
PtrVal x231 = x224.at(2);
int x232 = (int)proj_IntV(x231);
immer::map<int, Ptr<Stream>> x233 = x225.opened_files;
int64_t x234 = x232 == SEEK_SET ? ({
PtrVal x235 = x224.at(1);
int64_t x236 = proj_IntV(x235);
int64_t x237 = x236 < 0L ? -1L : ({
Ptr<Stream> x238 = x233.at(x227);
x238->cursor = x236;
x236;
});
x237;
}) : ({
int64_t x239 = x232 == SEEK_CUR ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
int64_t x240 = x238->cursor;
int64_t x241 = x240 + proj_IntV(x235);
int64_t x242 = x241 < 0L ? -1L : ({
x238->cursor = x241;
x241;
});
x242;
}) : ({
int64_t x243 = x232 == SEEK_END ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
Ptr<File> x244 = x238->file;
int x245 = x244->content.size();
int64_t x246 = (int64_t)x245 + proj_IntV(x235);
int64_t x247 = x246 < 0L ? -1L : ({
x238->cursor = x246;
x246;
});
x247;
}) : -1L;
x243;
});
x239;
});
x234;
});
x223.set_fs(x225);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x223, make_IntV(x230, 64))};
}
inline std::monostate syscall_lseek(SS x248, immer::flex_vector<PtrVal> x249, std::function<std::monostate(SS, PtrVal)> x250) {
FS x251 = x248.get_fs();
PtrVal x252 = x249.at(0);
int x253 = (int)proj_IntV(x252);
immer::map<int, Ptr<Stream>> x254 = x251.opened_files;
bool x255 = Map::contains(x254, x253);
int64_t x256 = !x255 ? -1L : ({
PtrVal x257 = x249.at(2);
int x258 = (int)proj_IntV(x257);
immer::map<int, Ptr<Stream>> x259 = x251.opened_files;
int64_t x260 = x258 == SEEK_SET ? ({
PtrVal x261 = x249.at(1);
int64_t x262 = proj_IntV(x261);
int64_t x263 = x262 < 0L ? -1L : ({
Ptr<Stream> x264 = x259.at(x253);
x264->cursor = x262;
x262;
});
x263;
}) : ({
int64_t x265 = x258 == SEEK_CUR ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
int64_t x266 = x264->cursor;
int64_t x267 = x266 + proj_IntV(x261);
int64_t x268 = x267 < 0L ? -1L : ({
x264->cursor = x267;
x267;
});
x268;
}) : ({
int64_t x269 = x258 == SEEK_END ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
Ptr<File> x270 = x264->file;
int x271 = x270->content.size();
int64_t x272 = (int64_t)x271 + proj_IntV(x261);
int64_t x273 = x272 < 0L ? -1L : ({
x264->cursor = x272;
x272;
});
x273;
}) : -1L;
x269;
});
x265;
});
x260;
});
x248.set_fs(x251);
return x250(x248, make_IntV(x256, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x168, immer::flex_vector<PtrVal> x169) {
FS x170 = x168.get_fs();
PtrVal x171 = x169.at(0);
int x172 = (int)proj_IntV(x171);
immer::map<int, Ptr<Stream>> x173 = x170.opened_files;
bool x174 = Map::contains(x173, x172);
immer::flex_vector<std::pair<SS, PtrVal>> x175 = !x174 ? ({
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(-1L, 64))};
}) : ({
PtrVal x176 = x169.at(1);
PtrVal x177 = x169.at(2);
int x178 = (int)proj_IntV(x177);
Ptr<Stream> x179 = x170.opened_files.at(x172);
immer::flex_vector<PtrVal> x180 = x168.at_seq(x176, x178).take((int)(int64_t)x178);
Ptr<File> x181 = x179->file;
int64_t x182 = x179->cursor;
// File.writeAt;
int x183 = (int)x182;
int x184 = x181->content.size();
int x185 = x183 - x184;
if (x185 > 0) {
immer::flex_vector<PtrVal> x186 = immer::flex_vector<PtrVal>(x185, IntV0);
immer::flex_vector<PtrVal> x187 = x181->content + x186;
x181->content = x187;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x188 = x181->content.take(x183);
immer::flex_vector<PtrVal> x189 = x188 + x180;
int x190 = x180.size();
immer::flex_vector<PtrVal> x191 = x181->content.drop(x183 + x190);
immer::flex_vector<PtrVal> x192 = x189 + x191;
x181->content = x192;
int64_t x193 = (int64_t)x190;
x179->cursor = x179->cursor + x193;
immer::map<int, Ptr<Stream>> x194 = x170.opened_files.insert(std::make_pair(x172, x179));
x170.opened_files = x194;
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(x193, 64))};
});
return x175;
}
inline std::monostate syscall_write(SS x195, immer::flex_vector<PtrVal> x196, std::function<std::monostate(SS, PtrVal)> x197) {
FS x198 = x195.get_fs();
PtrVal x199 = x196.at(0);
int x200 = (int)proj_IntV(x199);
immer::map<int, Ptr<Stream>> x201 = x198.opened_files;
bool x202 = Map::contains(x201, x200);
std::monostate x203 = !x202 ? ({
x195.set_fs(x198);
x197(x195, make_IntV(-1L, 64));
}) : ({
PtrVal x204 = x196.at(1);
PtrVal x205 = x196.at(2);
int x206 = (int)proj_IntV(x205);
Ptr<Stream> x207 = x198.opened_files.at(x200);
immer::flex_vector<PtrVal> x208 = x195.at_seq(x204, x206).take((int)(int64_t)x206);
Ptr<File> x209 = x207->file;
int64_t x210 = x207->cursor;
// File.writeAt;
int x211 = (int)x210;
int x212 = x209->content.size();
int x213 = x211 - x212;
if (x213 > 0) {
immer::flex_vector<PtrVal> x214 = immer::flex_vector<PtrVal>(x213, IntV0);
immer::flex_vector<PtrVal> x215 = x209->content + x214;
x209->content = x215;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x216 = x209->content.take(x211);
immer::flex_vector<PtrVal> x217 = x216 + x208;
int x218 = x208.size();
immer::flex_vector<PtrVal> x219 = x209->content.drop(x211 + x218);
immer::flex_vector<PtrVal> x220 = x217 + x219;
x209->content = x220;
int64_t x221 = (int64_t)x218;
x207->cursor = x207->cursor + x221;
immer::map<int, Ptr<Stream>> x222 = x198.opened_files.insert(std::make_pair(x200, x207));
x198.opened_files = x222;
x195.set_fs(x198);
x197(x195, make_IntV(x221, 64));
});
return x203;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x133, immer::flex_vector<PtrVal> x134) {
FS x135 = x133.get_fs();
PtrVal x136 = x134.at(0);
int x137 = (int)proj_IntV(x136);
immer::map<int, Ptr<Stream>> x138 = x135.opened_files;
bool x139 = Map::contains(x138, x137);
immer::flex_vector<std::pair<SS, PtrVal>> x140 = !x139 ? ({
x133.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x133, make_IntV(-1L, 64))};
}) : ({
PtrVal x141 = x134.at(1);
PtrVal x142 = x134.at(2);
Ptr<Stream> x143 = x135.opened_files.at(x137);
immer::flex_vector<PtrVal> x144 = x143->file->content.drop((int)x143->cursor);
immer::flex_vector<PtrVal> x145 = x144.take((int)(int64_t)(int)proj_IntV(x142));
int x146 = x145.size();
int64_t x147 = (int64_t)x146;
x143->cursor = x143->cursor + x147;
immer::map<int, Ptr<Stream>> x148 = x135.opened_files.insert(std::make_pair(x137, x143));
x135.opened_files = x148;
SS x149 = x133.update_seq(x141, x145);
x149.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x149, make_IntV(x147, 64))};
});
return x140;
}
inline std::monostate syscall_read(SS x150, immer::flex_vector<PtrVal> x151, std::function<std::monostate(SS, PtrVal)> x152) {
FS x153 = x150.get_fs();
PtrVal x154 = x151.at(0);
int x155 = (int)proj_IntV(x154);
immer::map<int, Ptr<Stream>> x156 = x153.opened_files;
bool x157 = Map::contains(x156, x155);
std::monostate x158 = !x157 ? ({
x150.set_fs(x153);
x152(x150, make_IntV(-1L, 64));
}) : ({
PtrVal x159 = x151.at(1);
PtrVal x160 = x151.at(2);
Ptr<Stream> x161 = x153.opened_files.at(x155);
immer::flex_vector<PtrVal> x162 = x161->file->content.drop((int)x161->cursor);
immer::flex_vector<PtrVal> x163 = x162.take((int)(int64_t)(int)proj_IntV(x160));
int x164 = x163.size();
int64_t x165 = (int64_t)x164;
x161->cursor = x161->cursor + x165;
immer::map<int, Ptr<Stream>> x166 = x153.opened_files.insert(std::make_pair(x155, x161));
x153.opened_files = x166;
SS x167 = x150.update_seq(x159, x163);
x167.set_fs(x153);
x152(x167, make_IntV(x165, 64));
});
return x158;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x58, immer::flex_vector<PtrVal> x59) {
FS x60 = x58.get_fs();
PtrVal x61 = x59.at(0);
int x62 = (int)proj_IntV(x61);
immer::map<int, Ptr<Stream>> x63 = x60.opened_files;
bool x64 = Map::contains(x63, x62);
immer::flex_vector<std::pair<SS, PtrVal>> x65 = !x64 ? ({
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(-1L, 32))};
}) : ({
Ptr<Stream> x66 = x60.opened_files.at(x62);
Ptr<File> x67 = x66->file;
/* getFile */;
Ptr<File> x68 = x60.root_file;
immer::flex_vector<String> x69 = Str::split(x67->name, "/");
immer::flex_vector<String> x70 = Vec::filter(x69, [&](auto x71) {
return x71.length() > 0;
});
Ptr<File> x72 = Vec::foldLeft(x70, x68, [&](auto x73, auto x74) {
bool x75 = x73 == nullptr || ({
bool x76 = Map::contains(x73->children, x74);
!x76;
});
Ptr<File> x77 = x75 ? nullptr : ({
Ptr<File> x78 = x73->children.at(x74);
x78;
});
return x77;
});
if (x72 != nullptr) {
Ptr<File> x79 = x66->file;
/* setFile */;
immer::flex_vector<String> x80 = Vec::filter(x69, [&](auto x81) {
return x81.length() > 0;
});
int x82 = x80.size();
immer::flex_vector<String> x83 = x80.take(x82 - 1);
Ptr<File> x84 = Vec::foldLeft(x83, x60.root_file, [&](auto x85, auto x86) {
bool x87 = x85 == nullptr || ({
bool x88 = Map::contains(x85->children, x86);
!x88;
});
Ptr<File> x89 = x87 ? nullptr : ({
Ptr<File> x90 = x85->children.at(x86);
x90;
});
return x89;
});
String x91 = x80.back();
String x92 = x79->name;
/* assertEq */;
ASSERT((x91 == x92), "setFile name should equal to last segment");
if (x84 != nullptr) {
immer::map<String, Ptr<File>> x93 = x84->children.insert(std::make_pair(x92, x79));
x84->children = x93;
}
immer::map<int, Ptr<Stream>> x94 = x60.opened_files.erase(x62);
x60.opened_files = x94;
}
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(0L, 32))};
});
return x65;
}
inline std::monostate syscall_close(SS x95, immer::flex_vector<PtrVal> x96, std::function<std::monostate(SS, PtrVal)> x97) {
FS x98 = x95.get_fs();
PtrVal x99 = x96.at(0);
int x100 = (int)proj_IntV(x99);
immer::map<int, Ptr<Stream>> x101 = x98.opened_files;
bool x102 = Map::contains(x101, x100);
std::monostate x103 = !x102 ? ({
x95.set_fs(x98);
x97(x95, make_IntV(-1L, 32));
}) : ({
Ptr<Stream> x104 = x98.opened_files.at(x100);
Ptr<File> x105 = x104->file;
/* getFile */;
Ptr<File> x106 = x98.root_file;
immer::flex_vector<String> x107 = Str::split(x105->name, "/");
immer::flex_vector<String> x108 = Vec::filter(x107, [&](auto x109) {
return x109.length() > 0;
});
Ptr<File> x110 = Vec::foldLeft(x108, x106, [&](auto x111, auto x112) {
bool x113 = x111 == nullptr || ({
bool x114 = Map::contains(x111->children, x112);
!x114;
});
Ptr<File> x115 = x113 ? nullptr : ({
Ptr<File> x116 = x111->children.at(x112);
x116;
});
return x115;
});
if (x110 != nullptr) {
Ptr<File> x117 = x104->file;
/* setFile */;
immer::flex_vector<String> x118 = Vec::filter(x107, [&](auto x119) {
return x119.length() > 0;
});
int x120 = x118.size();
immer::flex_vector<String> x121 = x118.take(x120 - 1);
Ptr<File> x122 = Vec::foldLeft(x121, x98.root_file, [&](auto x123, auto x124) {
bool x125 = x123 == nullptr || ({
bool x126 = Map::contains(x123->children, x124);
!x126;
});
Ptr<File> x127 = x125 ? nullptr : ({
Ptr<File> x128 = x123->children.at(x124);
x128;
});
return x127;
});
String x129 = x118.back();
String x130 = x117->name;
/* assertEq */;
ASSERT((x129 == x130), "setFile name should equal to last segment");
if (x122 != nullptr) {
immer::map<String, Ptr<File>> x131 = x122->children.insert(std::make_pair(x130, x117));
x122->children = x131;
}
immer::map<int, Ptr<Stream>> x132 = x98.opened_files.erase(x100);
x98.opened_files = x132;
}
x95.set_fs(x98);
x97(x95, make_IntV(0L, 32));
});
return x103;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
/* getFile */;
Ptr<File> x5 = x3.root_file;
immer::flex_vector<String> x6 = Str::split(get_string(x4, x1), "/");
immer::flex_vector<String> x7 = Vec::filter(x6, [&](auto x8) {
return x8.length() > 0;
});
Ptr<File> x9 = Vec::foldLeft(x7, x5, [&](auto x10, auto x11) {
bool x12 = x10 == nullptr || ({
bool x13 = Map::contains(x10->children, x11);
!x13;
});
Ptr<File> x14 = x12 ? nullptr : ({
Ptr<File> x15 = x10->children.at(x11);
x15;
});
return x14;
});
immer::flex_vector<std::pair<SS, PtrVal>> x16 = !(x9 != nullptr) ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x17 = x3.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x18 = Vec::filter(x6, [&](auto x19) {
return x19.length() > 0;
});
Ptr<File> x20 = Vec::foldLeft(x18, x3.root_file, [&](auto x21, auto x22) {
bool x23 = x21 == nullptr || ({
bool x24 = Map::contains(x21->children, x22);
!x24;
});
Ptr<File> x25 = x23 ? nullptr : ({
Ptr<File> x26 = x21->children.at(x22);
x26;
});
return x25;
});
Ptr<Stream> x27 = Stream::create(x20);
immer::map<int, Ptr<Stream>> x28 = x3.opened_files.insert(std::make_pair(x17, x27));
x3.opened_files = x28;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x17, 32))};
});
return x16;
}
inline std::monostate syscall_open(SS x29, immer::flex_vector<PtrVal> x30, std::function<std::monostate(SS, PtrVal)> x31) {
FS x32 = x29.get_fs();
PtrVal x33 = x30.at(0);
/* getFile */;
Ptr<File> x34 = x32.root_file;
immer::flex_vector<String> x35 = Str::split(get_string(x33, x29), "/");
immer::flex_vector<String> x36 = Vec::filter(x35, [&](auto x37) {
return x37.length() > 0;
});
Ptr<File> x38 = Vec::foldLeft(x36, x34, [&](auto x39, auto x40) {
bool x41 = x39 == nullptr || ({
bool x42 = Map::contains(x39->children, x40);
!x42;
});
Ptr<File> x43 = x41 ? nullptr : ({
Ptr<File> x44 = x39->children.at(x40);
x44;
});
return x43;
});
std::monostate x45 = !(x38 != nullptr) ? ({
x29.set_fs(x32);
x31(x29, make_IntV(-1L, 32));
}) : ({
int x46 = x32.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x47 = Vec::filter(x35, [&](auto x48) {
return x48.length() > 0;
});
Ptr<File> x49 = Vec::foldLeft(x47, x32.root_file, [&](auto x50, auto x51) {
bool x52 = x50 == nullptr || ({
bool x53 = Map::contains(x50->children, x51);
!x53;
});
Ptr<File> x54 = x52 ? nullptr : ({
Ptr<File> x55 = x50->children.at(x51);
x55;
});
return x54;
});
Ptr<Stream> x56 = Stream::create(x49);
immer::map<int, Ptr<Stream>> x57 = x32.opened_files.insert(std::make_pair(x46, x56));
x32.opened_files = x57;
x29.set_fs(x32);
x31(x29, make_IntV((int64_t)x46, 32));
});
return x45;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
